if ! $(TK_NAME) {
  EXIT "E/TK_NAME not set." ;
}
if ! $(TK_NONCE) {
  ECHO "W/TK_NONCE not set please set it in your _rules.ham, defaulted to 0. TK_NONCE is an arbitrary string that is added of every build target. It provides a way to force a rebuild of everything when it's changed. A good value is a incrementing number or commit hash that is updated when core must rebuild interface change." ;
}
TK_NONCE ?= 0 ;
if ! [ FExists $(TK_DIR) ] {
  EXIT "E/TK_DIR doesn't exist:" $(TK_DIR) ;
}
if ! [ FExists $(TOP_DIR) ] {
  EXIT "E/TOP_DIR doesn't exist:" $(TOP_DIR) ;
}

NOTFILE build_tools ;
NOTFILE tools ;
NOTFILE modlibs ;
NOTFILE tests ;
NOTFILE data ;
DEPENDS all : build_tools tools modlibs tests data ;

AssertVarDefined HAM_CPP_TOOLSET_NAME ;

if $(OS) = MACOSX {
  BUILD_BIN_LOA ?= $(BIN_LOA) ;
  BUILD_SUFEXE = "" ;
}
else if $(OS) = LINUX {
  BUILD_BIN_LOA ?= $(BIN_LOA) ;
  if $(BUILD_BIN_LOA) = lin-x64 {
    BUILD_SUFEXE = .x64 ;
  }
  else {
    BUILD_SUFEXE = .x64 ;
  }
}
else if $(NT) {
  BUILD_BIN_LOA ?= $(BIN_LOA) ;
  BUILD_SUFEXE = .exe ;
}
else {
  EXIT "Toolkit: Unknown host platform to set BUILD_BIN_LOA & BUILD_BIN_SUFEXE." ;
}
TK_ENV_FILE = toolkit-base-$(HAM_CPP_TOOLSET_NAME).ham ;
Import $(TK_ENV_FILE) : "E/Can't find toolkit's configuration for toolset:" $(TK_ENV_FILE:B:S) ;

TK_IMPORTED ?= ;

#----------------------------------------------------------------------
#     TARGET FEATURES
#----------------------------------------------------------------------
# Whether native executables can be built for this target
logVar TARGET_FEATURE_EXE ;
if ! $(TARGET_FEATURE_EXE) {
  NO_EXE = 1 ;
}

# Whether dynamic libraries can be built for this target
logVar TARGET_FEATURE_DLL ;
if ! $(TARGET_FEATURE_DLL) {
  NO_DLL = 1 ;
}

# Whether console applications can be built on this target. Console
# applications can be ran on the command line. This is different of
# TARGET_FEATURE_EXE in that this feature indicates that there's a
# terminal/console available to run other executables. For example running ni
# scripts test require both TARGET_FEATURE_EXE and TARGET_FEATURE_CONSOLE
# (since the ni executable needs to be run) whereas a regular test case only
# needs TARGET_FEATURE_EXE.
logVar TARGET_FEATURE_CONSOLE ;
if $(TARGET_FEATURE_CONSOLE) && ! $(TARGET_FEATURE_EXE) {
  EXIT "F/TARGET_FEATURE_CONSOLE set but not TARGET_FEATURE_EXE." ;
}

#----------------------------------------------------------------------
#     LOA
#----------------------------------------------------------------------
AssertVarDefined LOA_LINKER ;
AssertVarDefined LOA_OS ;
AssertVarDefined LOA_ARCH ;

# CPU_ARCH always keeps the raw CPU architecture
CPU_ARCH = $(LOA_ARCH) ;

if $(RTCPP) = 1 {
  DEFINES += _RTCPP ;
}

LIBS_LOA = $(LOA_LINKER)-$(LOA_OS)-$(LOA_ARCH) ;
logVar LIBS_LOA ;
BIN_LOA = $(LOA_OS)-$(LOA_ARCH) ;
logVar BIN_LOA ;

#----------------------------------------------------------------------
#     DEFINES
#----------------------------------------------------------------------
DEFINES +=
  HAM_LOA_LINKER_$(LOA_LINKER:U)
  HAM_LOA_OS_$(LOA_OS:U)
  HAM_LOA_ARCH_$(LOA_ARCH:U)
;

if $(FLYMAKE) = 1 {
  BUILD ?= da ;
}
else {
  BUILD ?= ra ;
}
logVar BUILD ;

BUILDEXT = $(BUILD) ;
logVar BUILDEXT ;

BUILDEXT_RA = ra ;
BUILDEXT_DA = da ;
switch $(BUILD) {
  case ra :
  case da : DEBUG = 1 ;
  case * : logFatal "Unknown BUILD type:" $(BUILD) ;
}

# Make sure the Features set is valid...
if $(FEATURES) = "" {
  FEATURES = ;
}
if $(EMBEDDED) = 1 {
  DEFINES += niEmbedded ;
  FEATURES ?= 25 ;
  BUILD_PKGTARGET_LIB ?= 0 ;
}
else {
  FEATURES ?= 30 ;
  BUILD_PKGTARGET_LIB ?= 1 ;
}
DEFINES += _FEATURES=$(FEATURES) ;

if $(FLYMAKE) = 1 {
  DEFINES += _FLYMAKE ;
}
if $(DEBUG) = 1 {
  DEFINES += _DEBUG ;
}
else {
  DEFINES += NDEBUG ;
}
if $(REDIST) = 1 {
  DEFINES += _REDIST ;
}
if $(PROFILER) = 1 {
  DEFINES += _PROFILER ;
}
if $(NO_PROFILER) = 1 {
  DEFINES += _NO_PROFILER ;
}

DEFINES += _BUILDEXT="\\\"$(BUILDEXT)\\\"" ;

# Lint, on by default in debug build
LINT ?= $(DEBUG) ;
logVar LINT ;

if ! ( $(FLYMAKE) = 1 ) {
  FEcho $(HOME)/_ham_flymake : "# Generated by toolkit.ham" : create nl ;
  FEcho $(HOME)/_ham_flymake : "export BUILD=$(BUILD)" : nl ;
  if $(BUILD_TARGET) {
    FEcho $(HOME)/_ham_flymake : "export BUILD_TARGET=$(BUILD_TARGET)" : nl ;
  }
  if $(HAM_TARGET_BIN_LOA) {
    FEcho $(HOME)/_ham_flymake : "export HAM_TARGET_BIN_LOA=$(HAM_TARGET_BIN_LOA)" : nl ;
  }
  FEcho $(HOME)/_ham_flymake : "export HAM_IMPORTED_TOOLSETS=\"$(HAM_IMPORTED_TOOLSETS)\"" : nl ;
}

#----------------------------------------------------------------------
#     DIRECTORIES
#----------------------------------------------------------------------

# Should be defined in the toolkit's _rules.ham
AssertVarDefined TK_DIR ;
AssertVarDefined TOP_DIR ;

TK_DIR_DOCS ?= [ FDirName $(TK_DIR) docs ] ;
logVar TK_DIR_DOCS ;
MakeLocate tkdir : $(TK_DIR_DOCS) ;

TK_DIR_BIN ?= [ FDirName $(TK_DIR) bin $(BIN_LOA) ] ;
logVar TK_DIR_BIN ;
MakeLocate tkdir : $(TK_DIR_BIN) ;

TK_DIR_LIBS ?= [ FDirName $(TK_DIR) libs $(LIBS_LOA) ] ;
logVar TK_DIR_LIBS ;
MakeLocate tkdir : $(TK_DIR_LIBS) ;

TK_DIR_OBJS ?= [ FDirName $(BASEOBJDIR) $(TK_NAME:L)-$(TK_NONCE:L) ] ;

if $(NO_DLL) = 1 {
  SUFDLL = $(SUFLIB) ;
  TK_DIR_DLL = $(TK_DIR_LIBS) ;
}
else {
  TK_DIR_DLL = $(TK_DIR_BIN) ;
}

NOTFILE tkdir ;
NOUPDATE tkdir ;
NOTFILE tkimport ;
NOUPDATE tkimport ;
DEPENDS all : tkdir tkimport ;

MakeLocate tkdir : $(TEMPDIR) ;
MakeLocate tkdir : $(BASEOBJDIR) ;

# Setup the run directories
RUN_DIR = $(TK_DIR_BIN) ;
RUN_SYMBOLS_DIR ?= $(TK_DIR_BIN) ;
RUN_EXE_SUFFIX = _$(BUILDEXT)$(SUFEXE) ;
AssertVarDefined RUN_EXE_SUFFIX ;

#----------------------------------------------------------------------
#     INFO
#----------------------------------------------------------------------
logVerbose "### BUILD ENV ###" ;
logVerbose "- Platform : "$(OS)" ($(OSPLAT))" ;
logVerbose "- LOA      : "$(LIBS_LOA) ;
logVerbose "- Toolset  : "$(HAM_CPP_TOOLSET_NAME) ;

#----------------------------------------------------------------------
#     BASE STUFF
#----------------------------------------------------------------------
# This is necessary to support includes where the include file name is the same
# in multiple folders. (as is stdafx.h)
rule tkHdrGrist {
  HDRGRIST = $(SUBDIR) ;
}
SUBDIRRULES += tkHdrGrist ;

# Return source files with the given extension
# EXAMPLE: GlobAllSrc DIR : cpp h asm ;
rule GlobAllSrcWithDir {
  return [ GLOB [ FDirName $(<) ] : "[^.]*."$(>) ] ;
}

rule GlobAllSrc {
  local r ;
  local t = [ GlobAllSrcWithDir $(<) : $(>) ] ;
  for _i in $(t) {
	r += $(_i:B)$(_i:S) ;
  }
  return $(r) ;
}

# tkFile TARGET : SOURCE : DEP
rule tkFileCopy {
  if $(<) != $(>) {
    DEPENDS $(<) : $(>) ;
  }
  MakeDirForTarget $(<) : $(<:D) ;
  FilePreserve $(<) : $(>) ;
  if $(3) {
    DEPENDS $(3) : $(<) ;
  }
}

# tkFile TARGET : SOURCE : OUTDIR
rule tkFile {
  if $(<) != $(>) {
    DEPENDS $(<) : $(>) ;
  }
  local p = [ FDirName $(3) $(<) ] ;
  MakeDirForTarget $(>) : $(p:D) ;
  FilePreserve $(p) : $(>) ;
  DEPENDS $(p) : $(>) ;
  return $(p) ;
}

# tkFile TARGET : SOURCE : OUTDIR
rule tkFileEXE {
  if $(<) != $(>) {
    DEPENDS $(<) : $(>) ;
  }
  local p = [ FDirName $(3) $(<) ] ;
  MakeDirForTarget $(>) : $(p:D) ;
  FilePreserveEXE $(p) : $(>) ;
  DEPENDS $(p) : $(>) ;
  return $(p) ;
}

# Append the specified files to the specified target.
# The target should have already been build.
rule tkFileAppend {
  DEPENDS $(<) : $(>) ;
}
actions tkFileAppend {
  echo - Appending [$(>)] to [$(<)]
  mv $(<) _temp_
  cat _temp_ $(>) > $(<)
  rm _temp_
}

# tkCopyDataToObjDir BASEDIR : FILES : ADDDIR ;
rule tkCopyDataToObjDir {
  local objDir = $(OBJDIR) ;
  if $(3) {
    objDir = [ FDirName $(OBJDIR) $(3) ] ;
  }
  local r = ;
  for _s in $(>) {
    local s = [ StrAfterI $(_s) : "$(<)/" ] ;
    # ECHO "--[$(<)/] $(_s) -> $(s)" ;
    local dest = [ FDirName $(objDir) $(s) ] ;
    MkDir $(dest:D) ;
    DEPENDS $(dest) : $(dest:D) ;
    # ECHO "$(_s) -> $(dest)" ;
    File $(dest) : $(_s) ;
    r += $(dest) ;
  }
  return $(r) ;
}

rule tkFindToolkitDir {
  local dirBase = [ FDirName $(WORK) $(1) ] ;
  return $(dirBase) ;
}

#----------------------------------------------------------------------
#     Compilation setup
#----------------------------------------------------------------------
Import toolkit-cpp.ham ;

#----------------------------------------------------------------------
#     Packages
#----------------------------------------------------------------------
if $(OSX) || $(IOS) {
  DEFAULT_PKGSRC_EXT = .cpp .c .cc .cni .m .mm ;
}
else {
  DEFAULT_PKGSRC_EXT = .cpp .c .cc .cni ;
}

# tkPkgSrc Extensions ;
# If extensions is not specified defaults to cpp/cc/c.
# Includes the _$PACKAGE_ModuleDef.cpp file.
rule tkPkgSrc {
  local ext = $(<) ;
  if ! $(<) {
    ext = $(DEFAULT_PKGSRC_EXT) ;
  }
  local s = [ GlobSrc $(SUBDIR) : $(ext) ] ;
  if $(PKGGROUP) = modules ||
     $(PKGGROUP) = modulelibs
  {
    s = $(s) _$(PACKAGE)_ModuleDef.cpp ;
  }
  return $(s) ;
}

# tkPkgSrcSubDirList d1..dn : files ;
rule tkPkgSrcSubDirLst {
  return [ SrcSubDir $(PACKAGE) : $(<) : $(OBJDIR) : $(>) ] ;
}
rule tkPkgSrcSubDirLstNoHdrs {
  return [ SrcSubDirNoHdrs $(PACKAGE) : $(<) : $(OBJDIR) : $(>) ] ;
}

# tkPkgSrcSubDir d1..dn : exts ;
# If extensions is not specified defaults to cpp/cc/c.
rule tkPkgSrcSubDir {
  local ext = $(>) ;
  if ! $(>) { ext = $(DEFAULT_PKGSRC_EXT) ; }
  return [ SrcSubDirGlob $(PACKAGE) : $(<) : $(OBJDIR) : $(ext) ] ;
}
rule tkPkgSrcSubDirNoHdrs {
  local ext = $(>) ;
  if ! $(>) { ext = $(DEFAULT_PKGSRC_EXT) ; }
  return [ SrcSubDirGlobNoHdrs $(PACKAGE) : $(<) : $(OBJDIR) : $(ext) ] ;
}

# tkPkgDataSubDirBin2H d1..dn : exts ;
rule tkPkgDataSubDirBin2H {
  local dir = $(1) ;
  local data = [ DataSubDirBin2H $(PACKAGE) : $(dir) : $(2) ] ;
  DEPENDS data : $(data) ;
  return $(data) ;
}

# tkPkgSrcRecSubDir d1..dn : exts ;
# Recursive version tkPkgSrcSubDir
rule tkPkgSrcRecSubDir {
  local BD = [ FDirName $(SUBDIR) $(1) ] ;
  local FD = [ ListDirsR $(BD) ] ;
  local SD =
    [ ListStrAfterI $(BD) : $(SUBDIR) ]
    [ ListStrAfterI $(FD) : $(SUBDIR) ]
  ;
  local ext = $(>) ;
  if ! $(>) {
    ext = $(DEFAULT_PKGSRC_EXT) ;
  }

  local F2 ;
  {
    local files = [ SrcSubDirGlob $(PACKAGE) : $(_sd) : $(OBJDIR) : $(ext) ] ;
    F2 += $(files) ;
  }
  for _sd in $(SD) {
    local files = [ SrcSubDirGlob $(PACKAGE) : $(_sd) : $(OBJDIR) : $(ext) ] ;
    F2 += $(files) ;
    # ECHO "F2 FOR $(_sd): " $(files) ;
  }

  return $(F2) ;
}

# tkPkgHdrs Dir ;
# Dir is relative to TK_DIR/include
rule tkPkgHdrs {
  local d = [ FDirName $(SUBDIR) API $(<) ] ;
  return [ GlobSrc $(d) : .h ] ;
}

# tkFindImportedLib LIB : BASE_DIR : EXT ;
rule tkFindImportedLib {
  # ECHO "... tkFindImportedLib:" $(1) ":" $(2) ":" $(3) ;
  local lib = $(1) ;
  local dir = $(2) ;
  local ext = $(3) ;
  ext ?= "_$(BUILDEXT)$(SUFLIB)" ;
  if $(dir) {
    local l = [ FDirName $(WORK) $(dir) libs $(LIBS_LOA) $(PREFIXDLL)$(1)$(ext) ] ;
    # Must exist in the other toolkit before we can go on
    AssertFExists "tkFindImportedLib with dir '$(dir)'" : $(l) ;
    return $(l) ;
  }
  else {
    local l = [ FDirName $(TK_DIR_LIBS) $(PREFIXDLL)$(1)$(ext) ] ;
    # Don't check for existance since these might not be built yet
    return $(l) ;
  }
}

# tkLinkLibs TARGET : LIB : DIR : EXT ;
# LIB is a library contained in the SDK's library folder.
rule tkLinkLibs {
  if $(PKGTYPE) != library {
    local l = [ tkFindImportedLib $(>) : $(3) : $(4) ] ;
    if ! ( $(NO_DEPS) = 1 ) {
      DEPENDS $(<) : $(l) ;
    }
    VarOnAddToFront LINKLIBS : $(<) : [ FQuote $(l) ] ;
  }
}

# tkLinkImpLibs TARGET : DLL : DIR : EXT ;
rule tkLinkImpLibs {
  if $(PKGTYPE) != library {
    local l = [ tkFindImportedLib $(>) : $(3) : $(4) ] ;
    if ! ( $(NO_DEPS) = 1 ) {
      if ( ! ( $(NO_DEPS_DLL) = 1 ) ) || ( ! [ FExists $(l) ] ) {
        DEPENDS $(<) : $(l) ;
      }
    }
    VarOnAddToFront LINKLIBS : $(<) : [ FQuote $(l) ] ;

    local DELAYLOAD = $(l:B) ;
    TargetLinkFlags $(<) : -DELAYLOAD:$(DELAYLOAD) ;
  }
}

# tkPkgLinkLibs LIB : DIR ;
rule tkPkgLinkLibs {
  tkLinkLibs $(PKGTARGET) : $(<) : $(>) ;
}

rule tkPkgLinkFlags {
  TargetLinkFlags $(PKGTARGETF) : $(<) ;
}

# tkDepExe TARGET : MODULENAME : DLLDIR : EXT
rule tkDepExe {
  local moduleName = $(2) ;
  local dir = $(3) ;
  local ext = $(4) ;
  ext ?= "_$(BUILDEXT)$(SUFEXE)" ;
  if $(dir) && ( $(dir) != $(TK_NAME) ) {
    local l = [ FDirName $(WORK) $(dir) bin $(BIN_LOA) $(moduleName)$(ext) ] ;
    # Must exist in the other toolkit before we can go on
    AssertFExists "tkDepExe with dir '$(dir)'" : $(l) ;
    return $(l) ;
  }
  else {
    local l = [ FDirName $(TK_DIR_BIN) $(moduleName)$(ext) ] ;
    # ECHO "... tkDepDll: nodir, l:" $(l) ;
    # Add a dependency instead of checking for existance since these might not
    # be built yet
    DEPENDS $(<) : $(moduleName) ;
    return $(l) ;
  }
}

# tkDepDll TARGET : MODULENAME : DLLDIR : EXT
rule tkDepDll {
  local moduleName = $(2) ;
  local dir = $(3) ;
  local ext = $(4) ;
  ext ?= "_$(BUILDEXT)$(SUFDLL)" ;
  if $(dir) {
    local l = [ FDirName $(WORK) $(dir) bin $(BIN_LOA) $(PREFIXDLL)$(moduleName)$(ext) ] ;
    # Must exist in the other toolkit before we can go on
    AssertFExists "tkDepDll with dir '$(dir)'" : $(l) ;
    return $(l) ;
  }
  else {
    local l = [ FDirName $(TK_DIR_BIN) $(PREFIXDLL)$(moduleName)$(ext) ] ;
    # ECHO "... tkDepDll: nodir, l:" $(l) ;
    # Add a dependency instead of checking for existance since these might not
    # be built yet
    DEPENDS $(<) : $(moduleName) ;
    return $(l) ;
  }
}

# tkLinkDll TARGET : MODULENAME : DLLDIR : LIBDIR
rule tkLinkDll {
  if $(NO_DLL) = 1 {
    tkLinkLibs $(<) : $(>) : $(4) ;
  }
  else {
    if $(DLLIMPLIB) = 1 {
      tkLinkImpLibs $(<) : $(>)_$(BUILDEXT) : $(4) : .dll.lib ;
    }
    else {
      VarOnAddToFront LINKLIBS : $(<) : -l$(>)_$(BUILDEXT) ;
    }
    tkDepDll $(<) : $(>) : $(3) ;
  }
}

rule tkPkgLinkDll {
  tkLinkDll $(PKGTARGET) : $(<) : $(2) : $(2) ;
}

# tkDefPackage name : version : type : output/final directory : customsuffix ;
rule tkDefPackage
{
  # Clear global variables...
  API = ;
  IDLS = ;
  SRC = ;
  ALLSRC = ;
  BUILD_SRC = ;
  SRC_EXTRA = ;
  OBJS_EXTRA = ;
  # Setup package variables
  PACKAGE = $(1) ;
  PACKAGE_DIR = [ FSubDirAbsName ] ;
  VERSION = $(2) ;
  PKGVER  = $(PACKAGE)-$(VERSION) ;
  OUTDIR  = [ FDirName $(4) ] ;
  PKGOPTIM = ;
  PKGGROUP = $(3) ;
  PKGTARGET_LIB = ;
  PKGTARGET_JS = ;
  PKGTARGET_WASM = ;

  # Use the C++ toolset name rather than the linker name so that multiple
  # compilers can be used safely on the same platform.
  local LINKER_OS = $(HAM_CPP_TOOLSET_NAME:L) ;
  if $(LINKER_OS) != $(LOA_OS) {
    LINKER_OS = $(LOA_OS)-$(LINKER_OS) ;
  }
  OBJDIR = [ FDirName
  $(TK_DIR_OBJS)
  $(LINKER_OS)-$(LOA_ARCH)-$(BUILD)
  $(PACKAGE) ] ;
  PKGBUILD = $(PACKAGE)_$(BUILDEXT) ;
  if $(PKGGROUP) = modules || $(PKGGROUP) = modulelibs || $(PKGGROUP) = dll || $(PKGGROUP) = tooldll {
    if ( $(PKGGROUP) = tooldll ) {
      DEPENDS tools : tooldll ;
      PKGTYPE = tooldll ;
    }
    else {
      DEPENDS modlibs : $(PKGGROUP) ;
      PKGTYPE = dll ;
    }
    if $(NO_DLL) {
      PKGBUILD = $(PREFIXDLL)$(PKGBUILD) ;
      PKGTARGET = $(PKGBUILD:S=$(SUFLIB)) ;
      PKGTYPE = library ;
      OUTDIR = $(TK_DIR_LIBS) ;
    }
    else {
      PKGBUILD = $(PREFIXDLL)$(PKGBUILD) ;
      PKGTARGET = $(PKGBUILD:S=$(SUFDLL)) ;
      if ( $(BUILD_PKGTARGET_LIB) = 1 ) && ( $(PKGGROUP) = modulelibs ) {
        PKGTARGET_LIB = $(PKGBUILD:S=$(SUFLIB)) ;
      }
    }
  }
  else if $(PKGGROUP) = libs {
    PKGBUILD = $(PREFIXDLL)$(PKGBUILD) ;
    PKGTARGET = $(PKGBUILD:S=$(SUFLIB)) ;
    PKGTYPE = library ;
    DEPENDS modlibs : $(PKGGROUP) ;
  }
  else if $(PKGGROUP) = rawbin || $(PKGGROUP) = tools || $(PKGGROUP) = tests {
    PKGTARGET = $(PKGBUILD:S=$(SUFEXE)) ;
    PKGTYPE = binary ;
    if $(PKGGROUP) = rawbin {
      FilePreserve [ FDirName $(OUTDIR:/) $(PACKAGE:S=$(SUFEXE)) ] : $(PKGTARGET:/) ;
    }
    if $(SUFEXE) = .html {
      PKGTARGET_JS = $(PKGBUILD:S=.js) ;
      FilePreserve [ FDirName $(OUTDIR:/) $(PKGTARGET_JS) ] : $(PKGTARGET_JS:/) ;
      PKGTARGET_WASM = $(PKGBUILD:S=.wasm) ;
      FilePreserve [ FDirName $(OUTDIR:/) $(PKGTARGET_WASM) ] : $(PKGTARGET_WASM:/) ;
    }
  }
  else {
    EXIT "E/Package '"$(PACKAGE)"', unknown package group '"$(PKGGROUP)"', should be one of: modules, modulelibs, dll, tooldll, libs, rawbin, tools or tests." ;
  }

  LINKFLAGS on $(PKGTARGET) ?= $(LINKFLAGS) ;
  LINKLIBS on $(PKGTARGET) ?= $(LINKLIBS) ;
  if $(PKGTARGET_LIB) {
    LINKFLAGS on $(PKGTARGET_LIB) ?= $(LINKFLAGS) ;
    LINKLIBS on $(PKGTARGET_LIB) ?= $(LINKLIBS) ;
  }

  if $(5) {
    PKGTARGETF = $(PKGTARGET:S=$(5)) ;
    logVerbose "- Custom Extension $(cpSrc) -> $(cpDst)" ;
  }
  else {
    PKGTARGETF = $(PKGTARGET) ;
  }

  # Target directory
  LOCATE_TARGET = $(OBJDIR) ;
  MakeLocate $(PKGTARGET) : $(OUTDIR) ;
  MakeLocate $(PKGTARGET) : $(OBJDIR) ;
  DEPENDS $(PKGTARGET) : tkdir ;
  DEPENDS $(PKGTARGET) : tkimport ;
  if $(PKGTARGET_LIB) {
    MakeLocate $(PKGTARGET_LIB) : $(TK_DIR_LIBS) ;
    MakeLocate $(PKGTARGET_LIB) : $(OBJDIR) ;
    DEPENDS $(PKGTARGET_LIB) : tkdir ;
    DEPENDS $(PKGTARGET_LIB) : tkimport ;
  }
  if $(PKGTARGET_JS) {
    MakeLocate $(PKGTARGET_JS) : $(TK_DIR_BIN) ;
    MakeLocate $(PKGTARGET_JS) : $(OBJDIR) ;
    DEPENDS $(PKGTARGET_JS) : $(PKGTARGETF) ;
    DEPENDS $(PKGTARGET_JS) : tkdir ;
    DEPENDS $(PKGTARGET_JS) : tkimport ;
  }
  if $(PKGTARGET_WASM) {
    MakeLocate $(PKGTARGET_WASM) : $(TK_DIR_BIN) ;
    MakeLocate $(PKGTARGET_WASM) : $(OBJDIR) ;
    DEPENDS $(PKGTARGET_WASM) : $(PKGTARGETF) ;
    DEPENDS $(PKGTARGET_WASM) : tkdir ;
    DEPENDS $(PKGTARGET_WASM) : tkimport ;
  }
  DEPENDS $(PKGGROUP) : $(PACKAGE) ;
  DEPENDS all : $(PKGGROUP) ;

  logVerbose "[ $(PKGBUILD) - $(VERSION) : $(PKGGROUP) [$(PKGTYPE)] ]" ;
  logVerbose "- Platform    : $(OS) ($(OSPLAT))" ;
  logVerbose "- Defines     :" $(DEFINES) ;
  logVerbose "- ObjDir      : $(OBJDIR)" ;
  logVerbose "- OutDir      : $(OUTDIR)" ;
  logVerbose "- Type        : $(PKGTYPE)" ;
  logVerbose "- Target      : $(PKGTARGET)" ;
  logVerbose "- Target File : $(PKGTARGETF)" ;
}

# tkDefModuleEx module_name : version : outdir : depdir : group ;
rule tkDefModuleEx
{
  tkDefPackage $(1) : $(2) : $(5) : $(3) ;
  MODXML = [ FSubDirAbsName "_"$(PACKAGE)"_Desc.xml" ] ;
  Clean clean : $(MODXML) ;
}

# tkDefModule module_name : version : (depdir) ;
rule tkDefModule {
  tkDefModuleEx $(<) : $(>) : $(TK_DIR_BIN) : $(3) : modules ;
}

# tkDefModule module_name : version : (depdir) ;
rule tkDefModuleLib {
  tkDefModuleEx $(<) : $(>) : $(TK_DIR_BIN) : $(3) : modulelibs ;
}

# tkDefLib lib_name : version ;
rule tkDefLib {
  tkDefPackage $(1) : $(2) : libs : $(TK_DIR_LIBS) ;
}

# tkDefTest test_name : version ;
rule tkDefTest {
  tkDefPackage $(1) : $(2) : tests : $(TK_DIR_BIN) ;
}

# tkDefTool tool_name : version : destDir ;
rule tkDefTool {
  local destDir = $(TK_DIR_BIN) ;
  if $(3) {
    destDir = $(3) ;
  }
  tkDefPackage $(1) : $(2) : tools : $(destDir) ;
}

# tkIncludeDep dira dirb
rule tkIncludeDep {
  if $(NO_DEPS) = 1 { return ; }
  if [ IncludeOnce $(1) ] = 0 {
    SubInclude $(1) ;
  }
}

# tkDepends target : depend_on : dira dirb
rule tkDepends {
  if $(NO_DEPS) = 1 { return ; }
  local depDir = $(3) ;
  if ! $(depDir) {
    depDir = TOP $(2) src ;
  }
  if [ IncludeOnce $(depDir) ] = 0 {
    SubInclude $(depDir) ;
  }
  DEPENDS $(<) : $(>) ;
}

rule tkDepends+Package {
  NotFile $(<)_$(PACKAGE) ;
  DEPENDS $(<)_$(PACKAGE) : $(>) ;
  DEPENDS $(<) : $(<)_$(PACKAGE) ;
  DEPENDS $(PACKAGE) : $(<)_$(PACKAGE) ;
}

# tkBuildPackage SOURCES : options : CHK_SOURCES : NOPCH-SOURCES : EXTRA_OBJS : MODDEPS_FOR_LIBLINK ;
# REM: Requires tkDefPackage to have been called first (or any of the tkDef* rule).
rule tkBuildPackage
{
  local NOAUTOBUILD = 0 ;
  local _exsrc = $(3) ; # Only applies the flags, not included directly into the final target
  local _src = $(<) ;
  local _nopchsrc = $(4) ;
  local _extra_objs = $(5) ;
  local _ei = 0 ;
  local _pch = ;
  local _cpredist = 1 ;
  local _console = 0 ;
  local _exc = 0 ;
  local _rtti = 0 ;
  local _unicode = 0 ;
  local _stamp = "" ;
  local _data = 0 ;

  if $(ALL_SRC_USE_PCH) = 1 {
    # We include all files as 'pch' if not using GCC
    _src += $(_nopchsrc) ;
    _nopchsrc = ;
  }

  OPT_CRTDLL = 0 ;
  OPT_MINSIZE = 0 ;
  OPT_NOOPT = 0 ;
  ### Parse options ###
  for _i in $(>) {
    switch $(_i) {
        # Use precompiled header, should be the first option if specified
      case pch :
        if $(SUFPCH) && ( ! ( $(NO_PCH) = 1 ) )  && ( ( ! $(FLYMAKE) ) || ( $(FLYMAKE_PCH) = 1 ) ) {
          # Use _exsrc
          _pch = [ tkC++Pch PCH_$(PACKAGE) : stdafx.cpp : $(_src) $(_exsrc) : $(_nopchsrc) : $(>) ] ;
          # _exsrc += stdafx.cpp ;
        }
        # Require exceptions
      case exc :
        _exc = 1 ;
        # Can lint
      case lint :
        if $(LINT) = 1 {
          tkCC++Lint $(_exsrc) $(_src) $(_nopchsrc) ;
        }
        # Dont call CC++Build automatically
      case noautobuild :
        NOAUTOBUILD = 1 ;
        # No CRT DLL
      case nocrt :
        OPT_CRTDLL = 2 ;
        # Use the CRT DLL
      case crtdll :
        OPT_CRTDLL = 1 ;
        # Min size optimization
      case minsz :
        OPT_MINSIZE = 1 ;
        # No optimization
      case noopt :
        OPT_NOOPT = 1 ;
        # Dont copy the output in the redist directory
      case noredist :
        _cpredist = 0 ;
        # Enable RTTI
      case rtti :
        _rtti = 1 ;
        # Console application
      case console :
        _console = 1 ;
        # Unicode (UTF16) application
      case unicode :
        _unicode = 1 ;
        # Output to a stamped target if STAMP is not empty
      case stamp :
        if $(STAMP) {
          _stamp = -$(STAMP) ;
        }
      case data :
        _data = 1 ;
      case * :
        ECHO "Unknown Build Option :" $(_i) ;
    }
  }

  local _allsrc = $(_exsrc) $(_src) $(_nopchsrc) ;

  if $(_unicode) = 1 {
    ObjectDefines $(_allsrc)  : _UNICODE UNICODE ;
  }
  else {
    ObjectDefines $(_allsrc) : _UTF8 ;
  }

  if $(_exc) = 0 {
    tkNoC++Exceptions $(_allsrc) ;
    ObjectDefines $(_allsrc)  : _CPP_NO_EXCEPTIONS CPP2_NO_EXCEPTIONS ;
  }
  else {
    tkC++Exceptions $(_allsrc) ;
    ObjectDefines $(_allsrc)  : _CPP_EXCEPTIONS ;
  }

  if $(_rtti) = 0 {
    tkNoC++RTTI $(_allsrc) ;
    ObjectDefines $(_allsrc)  : _CPP_NO_RTTI CPP2_NO_RTTI ;
  }
  else {
    tkC++RTTI $(_allsrc) ;
    ObjectDefines $(_allsrc)  : _CPP_RTTI ;
  }

  logVerbose "- Build options of '$(PKGTARGET)' :" $(>) ;

  if $(NOAUTOBUILD) = 0 {
    tkCC++Build $(_exsrc) $(_src) $(_nopchsrc) ;
  }
  ObjectOptimFlags $(_exsrc) $(_src) $(_nopchsrc) : $(PKGOPTIM) ;
  OPTIM on $(_pch) = $(PKGOPTIM) ;

  ### List of built files ###
  local f = ;

  ### Main build output ###
  _src += $(_nopchsrc) ;

  local is_exe = 0 ;
  local t = $(PKGBUILD) ;
  logVar PKGBUILD ;
  if $(PKGTYPE) = dll || $(PKGTYPE) = tooldll {
    ObjectDefines $(_allsrc) : _TARGET_DLL ;
    SharedLibrary $(t) : $(_src) : : : $(_extra_objs) ;

    if $(PKGTARGET_LIB) {
      local tlib_obj = [ FDirName $(OBJDIR) $(PKGTARGET_LIB) ] ;
      # Use LibraryFromObjects separately so that the target library is
      # correctly bound and recognized as a separate target
      LibraryFromObjects $(tlib_obj) : $(_src:S=$(SUFOBJ)) $(_extra_objs) ;
      DEPENDS $(PACKAGE)_lib : $(tlib_obj) ;
      f += $(tlib_obj) ;
      if $(_cpredist) = 1 {
        local tlib_redist = [ FDirName $(TK_DIR_LIBS) $(PKGTARGET_LIB:B)$(_stamp)$(PKGTARGET_LIB:S) ] ;
        FilePreserve $(tlib_redist) : $(tlib_obj) ;
        DEPENDS $(PACKAGE)_lib : $(tlib_redist) ;
        f += $(tlib_redist) ;
      }
    }

    # Copy the import library (for Windows DLL)
    if $(DLLIMPLIB) = 1 {
      local impLib = $(PKGTARGETF:B:S)$(SUFLIB) ;
      local srcLib = [ FDirName $(OBJDIR) $(impLib) ] ;
      DEPENDS $(srcLib) : $(PKGTARGETF) ;

      local dstLib = [ FDirName $(TK_DIR_LIBS) $(impLib) ] ;
      Touch $(srcLib) ;
      FilePreserve $(dstLib) : $(srcLib) ;
      Clean clean : $(dstLib) ;

      f += $(dstLib) ;
    }
  }
  else if $(PKGTYPE) = library {
    ObjectDefines $(_allsrc) : _TARGET_LIB ;
    Library $(t) : $(_src) : $(_extra_objs) ;
  }
  else {
    is_exe = 1 ;
    ObjectDefines $(_allsrc) : _TARGET_EXE ;
    Main $(t) : $(_src) : $(_extra_objs) ;
  }

  ### Set RPath and the DLL search paths ###
  if ( $(PKGTYPE) != library ) && ( $(TARGET_FEATURE_DLL) = 1 ) {
    if $(LOA_OS) = nt {
      local DLLLOAD_SEARCH_PATHS = ".;$(TK_NAME:E);$(TK_IMPORTED:EJ=;)" ;
      ObjectDefines $(_allsrc) : DLLLOAD_SEARCH_PATHS="\"$(DLLLOAD_SEARCH_PATHS)\"" ;
    }
    else if $(LOA_OS) = osx {
      local toolkits = $(TK_NAME) $(TK_IMPORTED) ;
      for _t in $(toolkits) {
        local lpath = [ tkFindToolkitDir $(_t) bin $(BIN_LOA) ] ;
        local rpath = [ FDirName .. .. .. $(_t) bin $(BIN_LOA) ] ;
        LINKFLAGS on $(PKGTARGET) += -L $(lpath) -rpath @loader_path/$(rpath) ;
      }
    }
    else {
      logFatal "Dont know how to link DLL to current target:" $(PKGTARGET) "LOA_OS:" $(LOA_OS) "LOA_LINKER" $(LOA_LINKER) ;
    }
  }

  ### Copy into the redist/output directory ###
  local d = $(PKGTARGET) ;
  DEPENDS $(d) : tkdir ;
  if $(_cpredist) = 1 {
    local p = [ tkFile $(PKGTARGETF:B)$(_stamp)$(PKGTARGETF:S) : $(d) : $(OUTDIR) ] ;
    if $(is_exe) {
      MODE on $(p) = $(EXEMODE) ;
      Chmod $(p) ;
    }
    f += $(p) ;

    if $(PKGTARGET_JS) {
      local p = [ tkFile $(PKGTARGET_JS:B)$(_stamp)$(PKGTARGET_JS:S) : $(PKGTARGET_JS) : $(TK_DIR_BIN) ] ;
      DEPENDS $(PACKAGE)_js : $(p) ;
      f += $(p) ;
    }

    if $(PKGTARGET_WASM) {
      local p = [ tkFile $(PKGTARGET_WASM:B)$(_stamp)$(PKGTARGET_WASM:S) : $(PKGTARGET_WASM) : $(TK_DIR_BIN) ] ;
      DEPENDS $(PACKAGE)_wasm : $(p) ;
      f += $(p) ;
    }
  }
  else {
    f += $(d) ;

    if $(PKGTARGET_JS) {
      f += $(PKGTARGET_JS) ;
      DEPENDS $(PACKAGE)_js : $(PKGTARGET_JS) ;
    }

    if $(PKGTARGET_WASM) {
      f += $(PKGTARGET_WASM) ;
      DEPENDS $(PACKAGE)_wasm : $(PKGTARGET_WASM) ;
    }
  }

  DEPENDS $(PACKAGE) : $(f) ;
  NotFile $(PACKAGE) ;
  DEPENDS $(PKGGROUP) : $(PACKAGE) ;  # Group's deps

  ### Flymake ###
  FlyMakeSetup check-syntax : $(_exsrc) ;

  ### All files ###
  local _all = $(_src) $(_exsrc) $(_nopchsrc) ;

  ### Data ###
  if $(_data) = 1 {
    tkPkgDataSubDirBin2H data ;
  }

  return $(_all) ;
}

#----------------------------------------------------------------------
#     RUN
#----------------------------------------------------------------------
Import run.ham ;

#----------------------------------------------------------------------
#     TOOLSET
#----------------------------------------------------------------------
Import ham-toolset.ham ;

Import lint-fix-format.ham ;
