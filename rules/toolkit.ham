if ! $(TK_NAME) {
  EXIT "E/TK_NAME not set." ;
}
if ! [ FExists $(TK_DIR) ] {
  EXIT "E/TK_DIR doesn't exist:" $(TK_DIR) ;
}
if ! [ FExists $(TOP_DIR) ] {
  EXIT "E/TOP_DIR doesn't exist:" $(TOP_DIR) ;
}

Import log.ham ;
Import assert.ham ;
Import run.ham ;

NOTFILE pass1 ;
NOTFILE build_tools ;
NOTFILE tools ;
NOTFILE modlibs ;
NOTFILE tests ;
NOTFILE data ;
NOTFILE shaders ;

AssertVarDefined HAM_TOOLSET_NAME ;
AssertVarDefined HAM_TOOLSET_VER ;

if $(OS) = MACOSX {
  BUILD_BIN_LOA ?= $(BIN_LOA) ;
  BUILD_SUFEXE = $(SUFEXE) ;
}
else if $(OS) = LINUX {
  BUILD_BIN_LOA ?= $(BIN_LOA) ;
  if $(BUILD_BIN_LOA) = lin-x64 {
    BUILD_SUFEXE = .x64 ;
  }
  else {
    BUILD_SUFEXE = .x64 ;
  }
}
else if $(NT) {
  BUILD_BIN_LOA ?= $(BIN_LOA) ;
  BUILD_SUFEXE = .exe ;
}
else {
  EXIT "Toolkit: Unknown host platform to set BUILD_BIN_LOA & BUILD_BIN_SUFEXE." ;
}
TK_ENV_FILE = toolkit-base-$(HAM_TOOLSET_NAME).ham ;
Import $(TK_ENV_FILE) : "E/Can't find toolkit's configuration for toolset:" $(TK_ENV_FILE:B:S) ;

#----------------------------------------------------------------------
#     TARGET FEATURES
#----------------------------------------------------------------------
# Whether native executables can be built for this target
logVar TARGET_FEATURE_EXE ;
if ! $(TARGET_FEATURE_EXE) {
  NO_EXE = 1 ;
}

# Whether dynamic libraries can be built for this target
logVar TARGET_FEATURE_DLL ;
if ! $(TARGET_FEATURE_DLL) {
  NO_DLL = 1 ;
}

# Whether console applications can be built on this target. Console
# applications can be ran on the command line. This is different of
# TARGET_FEATURE_EXE in that this feature indicates that there's a
# terminal/console available to run other executables. For example running ni
# scripts test require both TARGET_FEATURE_EXE and TARGET_FEATURE_CONSOLE
# (since the ni executable needs to be run) whereas a regular test case only
# needs TARGET_FEATURE_EXE.
logVar TARGET_FEATURE_CONSOLE ;
if $(TARGET_FEATURE_CONSOLE) && ! $(TARGET_FEATURE_EXE) {
  EXIT "F/TARGET_FEATURE_CONSOLE set but not TARGET_FEATURE_EXE." ;
}

# Whether the target can/should build JNI interop
logVar TARGET_FEATURE_JNI ;

#----------------------------------------------------------------------
#     LOA
#----------------------------------------------------------------------
AssertVarDefined LOA_LINKER ;
AssertVarDefined LOA_OS ;
AssertVarDefined LOA_ARCH ;

# CPU_ARCH always keeps the raw CPU architecture
CPU_ARCH = $(LOA_ARCH) ;

if $(TARGET_FEATURE_JNI) {
  BUILD_JNI = 1 ;
  LOA_ARCH = $(LOA_ARCH)j ;
  DEFINES += _BUILD_JNI ;
}
else {
  BUILD_JNI = ;
}
if $(RTCPP) = 1 {
  DEFINES += _RTCPP ;
}

LIBS_LOA = $(LOA_LINKER)-$(LOA_OS)-$(LOA_ARCH) ;
logVar LIBS_LOA ;
BIN_LOA = $(LOA_OS)-$(LOA_ARCH) ;
logVar BIN_LOA ;

#----------------------------------------------------------------------
#     DEFINES
#----------------------------------------------------------------------
if $(FLYMAKE) = 1 {
  BUILD ?= da ;
}
else {
  BUILD ?= ra ;
}
logVar BUILD ;

BUILDEXT = $(BUILD) ;
logVar BUILDEXT ;

BUILDEXT_RA = ra ;
BUILDEXT_DA = da ;
switch $(BUILD) {
  case ra :
  case da : DEBUG = 1 ;
  case * : logFatal "Unknown BUILD type:" $(BUILD) ;
}

# Make sure the Features set is valid...
if $(FEATURES) = "" {
  FEATURES = ;
}
if $(EMBEDDED) = 1 {
  DEFINES += niEmbedded ;
  FEATURES ?= 25 ;
  BUILD_PKGTARGET_LIB ?= 0 ;
}
else {
  FEATURES ?= 30 ;
  BUILD_PKGTARGET_LIB ?= 1 ;
}
DEFINES += _FEATURES=$(FEATURES) ;

if $(FLYMAKE) = 1 {
  DEFINES += _FLYMAKE ;
}
if $(DEBUG) = 1 {
  DEFINES += _DEBUG ;
}
else {
  DEFINES += NDEBUG ;
}
if $(REDIST) = 1 {
  DEFINES += _REDIST ;
}
if $(PROFILER) = 1 {
  DEFINES += _PROFILER ;
}
if $(NO_PROFILER) = 1 {
  DEFINES += _NO_PROFILER ;
}

DEFINES += _BUILDEXT="\\\"$(BUILDEXT)\\\"" ;

# Lint, on by default in debug build
LINT ?= $(DEBUG) ;
logVar LINT ;

if ! ( $(FLYMAKE) = 1 ) {
  FEcho $(HOME)/_ham_flymake : "# Generated by toolkit.ham" : create nl ;
  FEcho $(HOME)/_ham_flymake : "export BUILD=$(BUILD)" : nl ;
  FEcho $(HOME)/_ham_flymake : "export TOOLSET=$(HAM_IMPORTED_TOOLSET)" : nl ;
}

#----------------------------------------------------------------------
#     DIRECTORIES
#----------------------------------------------------------------------

# Should be defined in the toolkit's _rules.ham
AssertVarDefined TK_DIR ;
AssertVarDefined TOP_DIR ;

TK_DIR_DOCS ?= [ FDirName $(TK_DIR) docs ] ;
logVar TK_DIR_DOCS ;
MakeLocate tkdir : $(TK_DIR_DOCS) ;

TK_DIR_BIN ?= [ FDirName $(TK_DIR) bin $(BIN_LOA) ] ;
logVar TK_DIR_BIN ;
MakeLocate tkdir : $(TK_DIR_BIN) ;

TK_DIR_INCLUDE ?= [ FDirName $(TK_DIR) include ] ;
logVar TK_DIR_INCLUDE ;
MakeLocate tkdir : $(TK_DIR_INCLUDE) ;

TK_DIR_LIBS ?= [ FDirName $(TK_DIR) libs $(LIBS_LOA) ] ;
logVar TK_DIR_LIBS ;
MakeLocate tkdir : $(TK_DIR_LIBS) ;

TK_DIR_JARS ?= [ FDirName $(TK_DIR) libs jars ] ;

if $(NO_DLL) = 1 {
  SUFDLL = $(SUFLIB) ;
  TK_DIR_DLL = $(TK_DIR_LIBS) ;
}
else {
  TK_DIR_DLL = $(TK_DIR_BIN) ;
}

NOTFILE tkdir ;
NOUPDATE tkdir ;
NOTFILE tkimport ;
NOUPDATE tkimport ;
DEPENDS all : tkdir tkimport ;

MakeLocate tkdir : $(TEMPDIR) ;
MakeLocate tkdir : $(BASEOBJDIR) ;

# Setup the run directories
RUN_DIR = $(TK_DIR_BIN) ;
RUN_SYMBOLS_DIR ?= $(TK_DIR_BIN) ;
RUN_EXE_SUFFIX = _$(BUILDEXT)$(SUFEXE) ;
AssertVarDefined RUN_EXE_SUFFIX ;

#----------------------------------------------------------------------
#     INFO
#----------------------------------------------------------------------
logVerbose "### BUILD ENV ###" ;
logVerbose "- Platform : "$(OS)" ($(OSPLAT))" ;
logVerbose "- LOA      : "$(LIBS_LOA) ;
logVerbose "- Toolset  : "$(HAM_TOOLSET_NAME)" ("$(HAM_TOOLSET_VER)")" ;

#----------------------------------------------------------------------
#     BASE STUFF
#----------------------------------------------------------------------
# This is necessary to support includes where the include file name is the same
# in multiple folders. (as is stdafx.h)
rule tkHdrGrist {
  HDRGRIST = $(SUBDIR) ;
}
SUBDIRRULES += tkHdrGrist ;

# Return source files with the given extension
# EXAMPLE: GlobAllSrc DIR : cpp h asm ;
rule GlobAllSrcWithDir {
  return [ GLOB [ FDirName $(<) ] : "[^.]*."$(>) ] ;
}

rule GlobAllSrc {
  local r ;
  local t = [ GlobAllSrcWithDir $(<) : $(>) ] ;
  for _i in $(t) {
	r += $(_i:B)$(_i:S) ;
  }
  return $(r) ;
}

# tkFile TARGET : SOURCE : DEP
rule tkFileCopy {
  if $(<) != $(>) {
    DEPENDS $(<) : $(>) ;
  }
  MakeDirForTarget $(<) : $(<:D) ;
  FilePreserve $(<) : $(>) ;
  if $(3) {
    DEPENDS $(3) : $(<) ;
  }
}

# tkFile TARGET : SOURCE : OUTDIR
rule tkFile {
  if $(<) != $(>) {
    DEPENDS $(<) : $(>) ;
  }
  local p = [ FDirName $(3) $(<) ] ;
  MakeDirForTarget $(>) : $(p:D) ;
  FilePreserve $(p) : $(>) ;
  DEPENDS $(p) : $(>) ;
  return $(p) ;
}

# tkFile TARGET : SOURCE : OUTDIR
rule tkFileEXE {
  if $(<) != $(>) {
    DEPENDS $(<) : $(>) ;
  }
  local p = [ FDirName $(3) $(<) ] ;
  MakeDirForTarget $(>) : $(p:D) ;
  FilePreserveEXE $(p) : $(>) ;
  DEPENDS $(p) : $(>) ;
  return $(p) ;
}

# Append the specified files to the specified target.
# The target should have already been build.
rule tkFileAppend {
  DEPENDS $(<) : $(>) ;
}
actions tkFileAppend {
  echo - Appending [$(>)] to [$(<)]
  mv $(<) _temp_
  cat _temp_ $(>) > $(<)
  rm _temp_
}

# tkCopyDataToObjDir BASEDIR : FILES : ADDDIR ;
rule tkCopyDataToObjDir {
  local objDir = $(OBJDIR) ;
  if $(3) {
    objDir = [ FDirName $(OBJDIR) $(3) ] ;
  }
  local r = ;
  for _s in $(>) {
    local s = [ StrAfterI $(_s) : "$(<)/" ] ;
    # ECHO "--[$(<)/] $(_s) -> $(s)" ;
    local dest = [ FDirName $(objDir) $(s) ] ;
    MkDir $(dest:D) ;
    DEPENDS $(dest) : $(dest:D) ;
    # ECHO "$(_s) -> $(dest)" ;
    File $(dest) : $(_s) ;
    r += $(dest) ;
  }
  return $(r) ;
}

#----------------------------------------------------------------------
#     API Copy
#----------------------------------------------------------------------

# tkAPICopy TARGET : MODULE : RELDIRS
rule tkAPICopy {
  local TARGET = API_$(<) ;
  NOTFILE $(TARGET) ;

  local r ;
  for _i in $(3) {
    local dir ;
    local idir ;
    local ddir ;
    if $(_i) = .. {
      dir = [ FDirName $(SUBDIR) API ] ;
      idir = "" ;
      ddir = [ FDirName $(TK_DIR_INCLUDE) $(idir) ] ;
    }
    else {
      if $(_i) = . {
        _i = ;
      }
      local base = [ FDirName $(SUBDIR) API $(2) ] ;
      dir = [ FDirName $(base) $(_i) ] ;
      idir = [ FDirName $(2) $(_i) ] ;
      ddir = [ FDirName $(TK_DIR_INCLUDE) $(idir) ] ;
    }
    local srcs = [ GlobAllSrc $(dir) : c cxx cpp h hxx hpp __h ] ;
    # ECHO "Dir: " $(dir) ;
    # ECHO "IDir: " $(idir) ;
    # ECHO "DDir: " $(ddir) ;
    # ECHO "RDir: " $(rdir) ;
    # ECHO "SUB: " $(SUBDIR) ;
    MakeLocate $(TARGET)_dir : $(ddir) ;
    NotFile $(TARGET)_dir ;
    NoUpdate $(TARGET)_dir ;
    for _j in $(srcs) {
      local s = [ FDirName $(dir) $(_j) ] ;
      local d = [ FDirName $(ddir) $(_j) ] ;
      if $(d:S) = ".__h" {
        d = $(d:S="") ;
      }
      reld = [ FDirName $(idir) $(d:B)$(d:S) ] ;
      reld = "<"$(SUBDIR)">"$(reld) ; # Our own grist...
      s = [ FGristFiles $(s) ] ;
      d = [ FGristFiles $(d) ] ;
      DEPENDS $(d) : $(TARGET)_dir ;
      FilePreserveRO $(d) : $(s) ;
      INCLUDES $(d) : $(s) ;
      INCLUDES $(reld) : $(s) ;
      r += $(d) ;
      # ECHO "$(d:S) $(s) -> $(d)" ;
      # ECHO "REL: $(reld)" ;
      DEPENDS $(TARGET) : $(d) ;
    }
  }
  DEPENDS $(<) : $(TARGET) ;
  DEPENDS API : $(TARGET) ;
  return $(r) ;
}

# tkIncludeCopy TARGET : FILES : INC_SUBDIR
rule tkIncludeCopy {
  local TARGET = API_$(<) ;
  NOTFILE $(TARGET) ;

  local r = ;

  local DEST_DIR ;
  if $(3) {
    DEST_DIR = [ FDirName $(TK_DIR_INCLUDE) $(3) ] ;
  }
  else {
    DEST_DIR = [ FDirName $(TK_DIR_INCLUDE) ] ;
  }
  MakeLocate $(TARGET)_dir : $(DEST_DIR) ;
  NotFile $(TARGET)_dir ;
  NoUpdate $(TARGET)_dir ;

  for _i in $(>) {
    local DEST = [ FDirName $(DEST_DIR) $(_i) ] ;
    local SRC = [ FDirName $(SUBDIR) $(_i) ] ;

    SRC = [ FGristFiles $(SRC) ] ;
    DEST = [ FGristFiles $(DEST) ] ;

    DEPENDS $(DEST) : $(TARGET)_dir ;
    FilePreserveRO $(DEST) : $(SRC) ;
    DEPENDS $(TARGET) : $(DEST) ;

    r += $(DEST) ;
    Clean clean : $(DEST) ;
  }
  DEPENDS $(<) : $(TARGET) ;
  DEPENDS API : $(TARGET) ;
  return $(r) ;
}

#----------------------------------------------------------------------
#     Compilation setup
#----------------------------------------------------------------------
HDRS += $(TK_DIR_INCLUDE) ;
SHADER_HDRS += $(TK_DIR_INCLUDE) ;
Import toolkit-cpp.ham ;
Import toolkit-shaders.ham ;

#----------------------------------------------------------------------
#     Packages
#----------------------------------------------------------------------
if $(OSX) || $(IOS) {
  DEFAULT_PKGSRC_EXT = .cpp .c .cc .cni .m .mm ;
}
else {
  DEFAULT_PKGSRC_EXT = .cpp .c .cc .cni ;
}

# tkPkgSrc Extensions ;
# If extensions is not specified defaults to cpp/cc/c.
# Includes the _$PACKAGE_ModuleDef.cpp file.
rule tkPkgSrc {
  local ext = $(<) ;
  if ! $(<) {
    ext = $(DEFAULT_PKGSRC_EXT) ;
  }
  local s = [ GlobSrc $(SUBDIR) : $(ext) ] ;
  if $(PKGGROUP) = modules ||
     $(PKGGROUP) = modulelibs
  {
    s = _$(PACKAGE)_ModuleDef.cpp $(s) ;
  }
  return $(s) ;
}

# tkPkgSrcSubDirList d1..dn : files ;
rule tkPkgSrcSubDirLst {
  return [ SrcSubDir $(PACKAGE) : $(<) : $(OBJDIR) : $(>) ] ;
}

# tkPkgSrcSubDir d1..dn : exts ;
# If extensions is not specified defaults to cpp/cc/c.
rule tkPkgSrcSubDir {
  local ext = $(>) ;
  if ! $(>) { ext = $(DEFAULT_PKGSRC_EXT) ; }
  return [ SrcSubDirGlob $(PACKAGE) : $(<) : $(OBJDIR) : $(ext) ] ;
}
rule tkPkgSrcSubDirNoHdrs {
  local ext = $(>) ;
  if ! $(>) { ext = $(DEFAULT_PKGSRC_EXT) ; }
  return [ SrcSubDirGlobNoHdrs $(PACKAGE) : $(<) : $(OBJDIR) : $(ext) ] ;
}

# tkPkgDataSubDirBin2H d1..dn : exts ;
rule tkPkgDataSubDirBin2H {
  local dir = $(1) ;
  local data = [ DataSubDirBin2H $(PACKAGE) : $(dir) : [ FDirName $(SUBDIR) $(dir) ] : $(2) ] ;
  DEPENDS data : $(data) ;
  DEPENDS pass1 : data ;
  return $(data) ;
}

# tkPkgSrcRecSubDir d1..dn : exts ;
# Recursive version tkPkgSrcSubDir
rule tkPkgSrcRecSubDir {
  local BD = [ FDirName $(SUBDIR) $(1) ] ;
  local FD = [ ListDirsR $(BD) ] ;
  local SD =
    [ ListStrAfterI $(BD) : $(SUBDIR) ]
    [ ListStrAfterI $(FD) : $(SUBDIR) ]
  ;
  local ext = $(>) ;
  if ! $(>) {
    ext = $(DEFAULT_PKGSRC_EXT) ;
  }

  local F2 ;
  {
    local files = [ SrcSubDirGlob $(PACKAGE) : $(_sd) : $(OBJDIR) : $(ext) ] ;
    F2 += $(files) ;
  }
  for _sd in $(SD) {
    local files = [ SrcSubDirGlob $(PACKAGE) : $(_sd) : $(OBJDIR) : $(ext) ] ;
    F2 += $(files) ;
    # ECHO "F2 FOR $(_sd): " $(files) ;
  }

  return $(F2) ;
}

# tkPkgHdrs Dir ;
# Dir is relative to TK_DIR/include
rule tkPkgHdrs {
  local d = [ FDirName $(SUBDIR) API $(<) ] ;
  return [ GlobSrc $(d) : .h ] ;
}

# tkFindImportedLib LIB : BASE_DIR : EXT ;
rule tkFindImportedLib {
  local dir = $(2) ;
  dir ?= $(TK_DIR_LIBS) ;
  local ext = $(3) ;
  ext ?= "_$(BUILDEXT)$(SUFLIB)" ;
  for _importedDir in $(TK_IMPORTED) {
    local dir = [ FDirName $(WORK) $(_importedDir) libs $(LIBS_LOA) ] ;
    local l2 = [ FDirName $(dir) $(PREFIXDLL)$(1)$(ext) ] ;
    if [ FExists $(l2) ] {
      return $(l2) ;
    }
  }
  return [ FDirName $(dir) $(PREFIXDLL)$(1)$(ext) ] ;
}

# tkLinkLibs TARGET : LIB : DIR : EXT ;
# LIB is a library contained in the SDK's library folder.
rule tkLinkLibs {
  if $(PKGTYPE) != library {
    local l = [ tkFindImportedLib $(>) : $(3) : $(4) ] ;
    if ! ( $(NO_DEPS) = 1 ) {
      DEPENDS $(<) : $(l) ;
    }
    VarOnAddToFront LINKLIBS : $(<) : [ FQuote $(l) ] ;
  }
}

rule tkLinkImpLibs {
  if $(PKGTYPE) != library {
    local l = [ tkFindImportedLib $(>) : $(3) : $(4) ] ;
    if ( ! ( $(NO_DLL_DEPS) = 1 ) ) || ( ! [ FExists $(l) ] ) {
      DEPENDS $(<) : $(l) ;
    }
    VarOnAddToFront LINKLIBS : $(<) : [ FQuote $(l) ] ;
  }
}

# tkPkgLinkLibs LIB : DIR ;
rule tkPkgLinkLibs {
  tkLinkLibs $(PKGTARGET) : $(<) : $(>) ;
}

# tkDepDll TARGET : MODULENAME : DIR
rule tkDepDll {
  local dir = $(3) ;
  dir ?= $(TK_DIR_DLL) ;
  if ! ( $(NO_DEPS) = 1 ) {
    local l = [ FDirName $(dir) $(PREFIXDLL)$(>)_$(BUILDEXT)$(SUFDLL) ] ;
    if ( ! ( $(NO_DLL_DEPS) = 1 ) ) || ( ! [ FExists $(l) ] ) {
      DEPENDS $(<) : $(l) ;
    }
  }
}

# tkLinkDll TARGET : MODULENAME : DIR
rule tkLinkDll {
  if $(NO_DLL) {
    tkLinkLibs $(<) : $(>) ;
  }
  else {
    if $(DLLIMPLIB) = 1 {
      tkLinkImpLibs $(<) : $(>)_$(BUILDEXT) : : .dll.lib ;
    }
    else {
      local dir = $(3) ;
      dir ?= $(TK_DIR_DLL) ;
      if $(ANDROID) = 1 {
        local qdir = [ FQuote $(dir) ] ;
        VarOnAddToFront LINKLIBS : $(<) : -L$(qdir) -l$(>)_$(BUILDEXT) ;
      }
      else {
        local l = [ FDirName $(dir) $(PREFIXDLL)$(>)_$(BUILDEXT)$(SUFDLL) ] ;
        VarOnAddToFront LINKLIBS : $(<) : [ FQuote $(l) ] ;
      }
    }
    tkDepDll $(<) : $(>) : $(3) ;
  }
}

rule tkPkgDepDll {
  tkDepDll $(PKGTARGET) : $(<) ;
}

rule tkPkgLinkDll {
  tkLinkDll $(PKGTARGET) : $(<) ;
}

# tkDefPackage name : version : type : output/final directory : customsuffix ;
rule tkDefPackage
{
  # Clear global variables...
  API = ;
  IDLS = ;
  SRC = ;
  ALLSRC = ;
  BUILD_SRC = ;
  SRC_EXTRA = ;
  OBJS_EXTRA = ;
  SRC_SHADERS = ;
  LIB_SHADERS = ;
  # Setup package variables
  PACKAGE = $(1) ;
  PACKAGE_DIR = [ FSubDirAbsName ] ;
  VERSION = $(2) ;
  PKGVER  = $(PACKAGE)-$(VERSION) ;
  OUTDIR  = [ FDirName $(4) ] ;
  PKGOPTIM = ;
  PKGGROUP = $(3) ;
  PKGTARGET_LIB = ;
  PKGTARGET_JS = ;
  PKGTARGETF2 = ;
  if $(PKGGROUP) = jar || $(PKGGROUP) = apk {
    OBJDIR = [ FDirName $(BASEOBJDIR) jvm-$(TK_NAME:L) $(PACKAGE) ] ;
    PKGBUILD = $(PACKAGE) ;
    PKGTARGET = $(PKGBUILD:S=.jar) ;
    PKGTYPE = jar ;
    if $(PKGGROUP) = apk {
      DEPENDS apps : $(PKGGROUP) ;
    }
    else {
      DEPENDS modlibs : $(PKGGROUP) ;
    }
  }
  else {
    OBJDIR = [ FDirName $(BASEOBJDIR) $(LIBS_LOA)-$(TK_NAME:L)-$(BUILD) $(PACKAGE) ] ;
    PKGBUILD = $(PACKAGE)_$(BUILDEXT) ;
    if $(PKGGROUP) = modules || $(PKGGROUP) = modulelibs || $(PKGGROUP) = dll || $(PKGGROUP) = tooldll {
      if ( $(PKGGROUP) = tooldll ) {
        DEPENDS tools : tooldll ;
        PKGTYPE = tooldll ;
      }
      else {
        DEPENDS modlibs : $(PKGGROUP) ;
        PKGTYPE = dll ;
      }
      if $(NO_DLL) {
        PKGBUILD = $(PREFIXDLL)$(PKGBUILD) ;
        PKGTARGET = $(PKGBUILD:S=$(SUFLIB)) ;
        PKGTYPE = library ;
        OUTDIR = $(TK_DIR_LIBS) ;
      }
      else {
        PKGBUILD = $(PREFIXDLL)$(PKGBUILD) ;
        PKGTARGET = $(PKGBUILD:S=$(SUFDLL)) ;
        if ( $(BUILD_PKGTARGET_LIB) = 1 ) && ( $(PKGGROUP) = modulelibs ) {
          PKGTARGET_LIB = $(PKGBUILD:S=$(SUFLIB)) ;
        }
      }
    }
    else if $(PKGGROUP) = libs {
      PKGBUILD = $(PREFIXDLL)$(PKGBUILD) ;
      PKGTARGET = $(PKGBUILD:S=$(SUFLIB)) ;
      PKGTYPE = library ;
      DEPENDS modlibs : $(PKGGROUP) ;
    }
    else if $(PKGGROUP) = rawbin || $(PKGGROUP) = tools || $(PKGGROUP) = tests {
      PKGTARGET = $(PKGBUILD:S=$(SUFEXE)) ;
      PKGTYPE = binary ;
      if $(PKGGROUP) = rawbin {
        FilePreserve [ FDirName $(OUTDIR:/) $(PACKAGE:S=$(SUFEXE)) ] : $(PKGTARGET:/) ;
      }
      if $(SUFEXE) = .html {
        PKGTARGET_JS = $(PKGBUILD:S=.js) ;
        FilePreserve [ FDirName $(OUTDIR:/) $(PKGTARGET_JS) ] : $(PKGTARGET_JS:/) ;
      }
    }
    else {
      EXIT "E/Package '"$(PACKAGE)"', unknown package group '"$(PKGGROUP)"', should be one of: modules, modulelibs, dll, tooldll, libs, rawbin, tools or tests." ;
    }

    LINKFLAGS on $(PKGTARGET) ?= $(LINKFLAGS) ;
    LINKLIBS on $(PKGTARGET) ?= $(LINKLIBS) ;
    if $(PKGTARGET_LIB) {
      LINKFLAGS on $(PKGTARGET_LIB) ?= $(LINKFLAGS) ;
      LINKLIBS on $(PKGTARGET_LIB) ?= $(LINKLIBS) ;
    }
  }

  if $(5) {
    PKGTARGETF = $(PKGTARGET:S=$(5)) ;
    logVerbose "- Custom Extension $(cpSrc) -> $(cpDst)" ;
  }
  else {
    PKGTARGETF = $(PKGTARGET) ;
  }
  if $(PKGTARGET_LIB) {
    PKGTARGETF2 = $(PKGTARGET_LIB) ;
  }
  if $(PKGTARGET_JS) {
    PKGTARGETF2 = $(PKGTARGET_JS) ;
  }

  # Target directory
  LOCATE_TARGET = $(OBJDIR) ;
  MakeLocate $(PKGTARGET) : $(OUTDIR) ;
  MakeLocate $(PKGTARGET) : $(OBJDIR) ;
  DEPENDS $(PKGTARGET) : tkdir ;
  DEPENDS $(PKGTARGET) : tkimport ;
  if $(PKGTARGET_LIB) {
    MakeLocate $(PKGTARGET_LIB) : $(TK_DIR_LIBS) ;
    MakeLocate $(PKGTARGET_LIB) : $(OBJDIR) ;
    DEPENDS $(PKGTARGET_LIB) : tkdir ;
    DEPENDS $(PKGTARGET_LIB) : tkimport ;
  }
  if $(PKGTARGET_JS) {
    MakeLocate $(PKGTARGET_JS) : $(TK_DIR_BIN) ;
    MakeLocate $(PKGTARGET_JS) : $(OBJDIR) ;
    DEPENDS $(PKGTARGET_JS) : $(PKGTARGETF) ;
    DEPENDS $(PKGTARGET_JS) : tkdir ;
    DEPENDS $(PKGTARGET_JS) : tkimport ;
  }
  DEPENDS $(PKGGROUP) : $(PACKAGE) ;
  DEPENDS all : $(PKGGROUP) ;

  logVerbose "[ $(PKGBUILD) - $(VERSION) : $(PKGGROUP) [$(PKGTYPE)] ]" ;
  logVerbose "- Platform    : $(OS) ($(OSPLAT))" ;
  logVerbose "- Defines     :" $(DEFINES) ;
  logVerbose "- ObjDir      : $(OBJDIR)" ;
  logVerbose "- OutDir      : $(OUTDIR)" ;
  logVerbose "- Type        : $(PKGTYPE)" ;
  logVerbose "- Target      : $(PKGTARGET)" ;
  logVerbose "- Target File : $(PKGTARGETF)" ;
  logVerbose "- Target2     :" $(PKGTARGETF2) ;
}

# tkDefModuleEx module_name : version : outdir : depdir : group ;
rule tkDefModuleEx
{
  tkDefPackage $(1) : $(2) : $(5) : $(3) ;
  if $(4) {
    DEPHDRS += [ FDirName $(TK_DIR_INCLUDE) $(4) ] ;
  }
  MODXML = [ FSubDirAbsName "_"$(PACKAGE)"_Desc.xml" ] ;
  Clean clean : $(MODXML) ;
}

# tkDefModule module_name : version : (depdir) ;
rule tkDefModule {
  tkDefModuleEx $(<) : $(>) : $(TK_DIR_BIN) : $(3) : modules ;
}

# tkDefModule module_name : version : (depdir) ;
rule tkDefModuleLib {
  tkDefModuleEx $(<) : $(>) : $(TK_DIR_BIN) : $(3) : modulelibs ;
}

# tkDefLib lib_name : version ;
rule tkDefLib {
  tkDefPackage $(1) : $(2) : libs : $(TK_DIR_LIBS) ;
}

# tkDefTest test_name : version ;
rule tkDefTest {
  tkDefPackage $(1) : $(2) : tests : $(TK_DIR_BIN) ;
}

# tkDefTool tool_name : version : destDir ;
rule tkDefTool {
  local destDir = $(TK_DIR_BIN) ;
  if $(3) {
    destDir = $(3) ;
  }
  tkDefPackage $(1) : $(2) : tools : $(destDir) ;
}

if $(BUILD_JNI) {
  # tkDefJar lib_name : version ;
  rule tkDefJar {
    tkDefPackage $(1) : $(2) : jar : $(TK_DIR_JARS) ;
  }
}

if $(ANDROID) {
  # tkDefJar lib_name : version ;
  rule tkDefApk {
    tkDefPackage $(1) : $(2) : apk : $(TK_DIR_JARS) ;
  }
}

# tkIncludeDep dira dirb
rule tkIncludeDep {
  if $(NO_DEPS) = 1 { return ; }
  if [ IncludeOnce $(1) ] = 0 {
    SubInclude $(1) ;
  }
}

# tkDepends target : depend_on : dira dirb
rule tkDepends {
  if $(NO_DEPS) = 1 { return ; }
  local depDir = $(3) ;
  if ! $(depDir) {
    depDir = TOP $(2) src ;
  }
  if [ IncludeOnce $(depDir) ] = 0 {
    SubInclude $(depDir) ;
  }
  DEPENDS $(<) : $(>) ;
}

rule tkDepends+Package {
  NotFile $(<)_$(PACKAGE) ;
  DEPENDS $(<)_$(PACKAGE) : $(>) ;
  DEPENDS $(<) : $(<)_$(PACKAGE) ;
  DEPENDS $(PACKAGE) : $(<)_$(PACKAGE) ;
}

# tkBuildPackage SOURCES : options : CHK_SOURCES : NOPCH-SOURCES : EXTRA_OBJS : MODDEPS_FOR_LIBLINK ;
# REM: Requires tkDefPackage to have been called first (or any of the tkDef* rule).
rule tkBuildPackage
{
  local NOAUTOBUILD = 0 ;
  local _exsrc = $(3) ; # Only applies the flags, not included directly into the final target
  local _src = $(<) ;
  local _nopchsrc = $(4) ;
  local _extra_objs = $(5) ;
  local _ei = 0 ;
  local _pch = ;
  local _cpredist = 1 ;
  local _pdb = 1 ;
  local _console = 0 ;
  local _jni = 0 ;
  local _exc = 0 ;
  local _rtti = 0 ;
  local _unicode = 0 ;
  local _stamp = "" ;
  local _shaders = 0 ;
  local _data = 0 ;

  if $(BUILD_JNI) {
    _jni = 1 ;
  }

  if $(ALL_SRC_USE_PCH) = 1 {
    # We include all files as 'pch' if not using GCC
    _src += $(_nopchsrc) ;
    _nopchsrc = ;
  }

  OPT_CRTDLL = 0 ;
  OPT_MINSIZE = 0 ;
  OPT_NOOPT = 0 ;
  ### Parse options ###
  for _i in $(>) {
    switch $(_i) {
        # Use precompiled header, should be the first option if specified
      case pch :
        if $(SUFPCH) && ( ! ( $(NO_PCH) = 1 ) )  && ( ( ! $(FLYMAKE) ) || ( $(FLYMAKE_PCH) = 1 ) ) {
          # Use _exsrc
          _pch = [ tkC++Pch PCH_$(PACKAGE) : stdafx.cpp : $(_src) $(_exsrc) : $(_nopchsrc) : $(>) ] ;
          # _exsrc += stdafx.cpp ;
        }
        # Require exceptions
      case exc :
        _exc = 1 ;
        tkC++Exceptions $(_exsrc) $(_src) $(_nopchsrc) ;
        # Can lint
      case lint :
        if $(LINT) = 1 {
          tkCC++Lint $(_exsrc) $(_src) $(_nopchsrc) ;
        }
        # Dont call CC++Build automatically
      case noautobuild :
        NOAUTOBUILD = 1 ;
        # No CRT DLL
      case nocrt :
        OPT_CRTDLL = 2 ;
        # Use the CRT DLL
      case crtdll :
        OPT_CRTDLL = 1 ;
        # Min size optimization
      case minsz :
        OPT_MINSIZE = 1 ;
        # No optimization
      case noopt :
        OPT_NOOPT = 1 ;
        # Dont copy the output in the redist directory
      case noredist :
        _cpredist = 0 ;
        # Dont copy the pdb in the redist directory
      case nopdb :
        _pdb = 0 ;
        # Enable RTTI
      case rtti :
        _rtti = 1 ;
        tkC++RTTI $(_exsrc) $(_src) $(_nopchsrc) ;
        # Console application
      case console :
        _console = 1 ;
        # Unicode (UTF16) application
      case unicode :
        _unicode = 1 ;
        # Output to a stamped target if STAMP is not empty
      case stamp :
        if $(STAMP) {
          _stamp = -$(STAMP) ;
        }
      case shaders :
        _shaders = 1 ;
      case data :
        _data = 1 ;
      case * :
        ECHO "Unknown Build Option :" $(_i) ;
    }
  }

  local _allsrc = $(_exsrc) $(_src) $(_nopchsrc) ;
  if $(_unicode) = 1 {
    ObjectDefines $(_allsrc)  : _UNICODE UNICODE ;
  }
  else {
    ObjectDefines $(_allsrc) : _UTF8 ;
  }
  if $(_exc) = 0 {
    tkNoC++Exceptions $(_allsrc) ;
  }
  if $(_rtti) = 0 {
    tkNoC++RTTI $(_allsrc) ;
  }

  logVerbose "- Build options of '$(PKGTARGET)' :" $(>) ;

  if $(NOAUTOBUILD) = 0 {
    tkCC++Build $(_exsrc) $(_src) $(_nopchsrc) ;
  }
  ObjectOptimFlags $(_exsrc) $(_src) $(_nopchsrc) : $(PKGOPTIM) ;
  OPTIM on $(_pch) = $(PKGOPTIM) ;

  ### Main build output ###
  _src += $(_nopchsrc) ;

  local is_exe = 0 ;
  local t = $(PKGBUILD) ;
  logVar PKGBUILD ;
  if $(PKGTYPE) = dll || $(PKGTYPE) = tooldll {
    ObjectDefines $(_allsrc) : _TARGET_DLL ;
    if $(PKGTARGET_LIB) {
      SharedAndStaticLibrary $(t) : $(_src) : : : $(_extra_objs) ;
    }
    else {
      SharedLibrary $(t) : $(_src) : : : $(_extra_objs) ;
    }
  }
  else if $(PKGTYPE) = library {
    ObjectDefines $(_allsrc) : _TARGET_LIB ;
    Library $(t) : $(_src) : $(_extra_objs) ;
  }
  else {
    is_exe = 1 ;
    ObjectDefines $(_allsrc) : _TARGET_EXE ;
    Main $(t) : $(_src) : $(_extra_objs) ;
  }

  ### Copy into the redist/output directory ###
  local d = $(PKGTARGET) ;
  DEPENDS $(d) : tkdir ;
  local f = ;
  if $(_cpredist) = 1 {
    local p = [ tkFile $(PKGTARGETF:B)$(_stamp)$(PKGTARGETF:S) : $(d) : $(OUTDIR) ] ;
    if $(is_exe) {
      MODE on $(p) = $(EXEMODE) ;
      Chmod $(p) ;
    }
    f += $(p) ;

    if $(PKGTARGET_LIB) {
      local p = [ tkFile $(PKGTARGET_LIB:B)$(_stamp)$(PKGTARGET_LIB:S) : $(PKGTARGET_LIB) : $(TK_DIR_LIBS) ] ;
      DEPENDS $(PACKAGE)_lib : $(p) ;
      f += $(p) ;
    }

    if $(PKGTARGET_JS) {
      local p = [ tkFile $(PKGTARGET_JS:B)$(_stamp)$(PKGTARGET_JS:S) : $(PKGTARGET_JS) : $(TK_DIR_BIN) ] ;
      DEPENDS $(PACKAGE)_js : $(p) ;
      f += $(p) ;
    }
  }
  else {
    f += $(d) ;

    if $(PKGTARGET_LIB) {
      f += $(PKGTARGET_LIB) ;
      DEPENDS $(PACKAGE)_lib : $(PKGTARGET_LIB) ;
    }

    if $(PKGTARGET_JS) {
      f += $(PKGTARGET_JS) ;
      DEPENDS $(PACKAGE)_js : $(PKGTARGET_JS) ;
    }
  }

  if $(SUFPDB) && $(_pdb) = 1 {
    local srcPDB = [ FDirName $(LOCATE_TARGET) $(d:S=$(SUFPDB)) ] ;
    local dstPDB = [ FDirName $(OUTDIR) $(d:B)$(_stamp)$(SUFPDB) ] ;
    DEPENDS $(srcPDB) : $(d) ;
    Touch $(srcPDB) ; # Make sure that the PDB's date is more recent than the output
    FilePreserve $(dstPDB) : $(srcPDB) ;
    f += $(dstPDB) ;

    if $(PKGTARGET_LIB) {
      local p = $(PKGTARGET_LIB) ;
      local srcPDB = [ FDirName $(LOCATE_TARGET) $(p:S=$(SUFPDB)) ] ;
      local dstPDB = [ FDirName $(TK_DIR_LIBS) $(p:B)$(_stamp)$(SUFPDB) ] ;
      DEPENDS $(srcPDB) : $(p) ;
      Touch $(srcPDB) ; # Make sure that the PDB's date is more recent than the output
      FilePreserve $(dstPDB) : $(srcPDB) ;
      f += $(dstPDB) ;
    }
  }

  # Import library, for MSVC, if its also potentially a static library
  if $(MSVC) = 1 && $(PKGTYPE) = dll {
    local impLib = $(PKGTARGETF:B:S)$(SUFLIB) ;
    local srcLib = [ FDirName $(OBJDIR) $(impLib) ] ;
    DEPENDS $(srcLib) : $(PKGTARGETF) ;

    LINKFLAGS on $(PKGTARGET) ?= $(LINKFLAGS) ;
    LINKFLAGS on $(PKGTARGET) += [ FQuoteFlag -IMPLIB: : $(srcLib) ] ;

    local dstLib = [ FDirName $(TK_DIR_LIBS) $(impLib) ] ;
    Touch $(srcLib) ;
    FilePreserve $(dstLib) : $(srcLib) ;
    Clean clean : $(dstLib) ;

    f += $(dstLib) ;
  }

  DEPENDS $(PACKAGE) : $(f) ;
  NotFile $(PACKAGE) ;
  DEPENDS $(PKGGROUP) : $(PACKAGE) ;  # Group's deps

  ### Flymake ###
  FlyMakeSetup check-syntax : $(_exsrc) ;

  ### All files ###
  local _all = $(_src) $(_exsrc) $(_nopchsrc) ;

  ObjectHdrs $(_all) : [ FDirName $(TK_DIR_INCLUDE) ] ;

  ### Shaders ###
  if $(_shaders) = 1 {
    if $(OSX) || $(IOS) {
      SRC_SHADERS = [ tkPkgSrcSubDir shaders : metal ] ;
      if ! [ ListGetFirst $(SRC_SHADERS) ] {
        EXIT "E/No metal shader found in:" [ FDirName $(SUBDIR) shaders ] ;
      }
      LIB_SHADERS = [ shaderMetalLibrary [ FDirName $(SUBDIR) shaders _allShaders ] : $(SRC_SHADERS) ] ;
      DEPENDS $(PACKAGE) : $(LIB_SHADERS).h ;
      # This solve the problem of having the generated header be correctly
      # included in dependencies because the SUBDIR isnt taken into account in
      # the automatic header resolve part.
      DEPENDS [ FGristFilesForDepends [ FDirName shaders $(LIB_SHADERS:B:S).h ] ]  : $(LIB_SHADERS).h ;
    }
  }

  ### Data ###
  if $(_data) = 1 {
    tkPkgDataSubDirBin2H data ;
  }

  return $(_all) ;
}
