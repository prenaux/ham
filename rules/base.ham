# /+\
#  +\    Copyright 1993-2002 Christopher Seiwald and Perforce Software, Inc.
# \+/
#
# This file is part of Jam - see jam.c for Copyright information.
#

#
# Variables modifiers:
#
# :B -> Select filename base. This does not include the suffix.
# :S -> Select last filename suffix, if any; this includes the last dot (.)
# :D -> Select directory path
# :P -> Select "parent" directory path.
# :G -> Select the grist.
#
# :B=basename -> Replace each element's base name. Does not change the suffix.
# :S=suffix -> Replace each element's last suffix by suffix.
# :D=path -> Replace each element's directory path by path.
# :G=grist -> Replace each element's grist by path.
# :R=root -> Prepend root to each element, if it's not already rooted/absolute.
#
# :E -> Expand to the empty string if the variable is undefined, or normally otherwise.
# :E=value -> Expand to a given value if the variable is undefined, or normally otherwise.
# :J=separator -> Expands the variable into a single string, by concatenating its element with separator.
# :/ -- convert all \ to /
#	:\ -- convert all / to \
# :L -> Lowercase the variable.
# :U -> Uppercase the variable.
#

# Special targets defined in this file:
#
# all       - parent of first, files, lib, exe
# first     - first dependent of 'all', for potential initialization
# files     - parent of all File targets
# lib       - parent of all Library targets
# exe       - parent of all Main targets
# dirs      - parent of all MkDir targets
# clean     - removes all File, Library, and Main targets
#

# Rules defined by this file:
#
# as obj.o : source.s ;         .s -> .o
# Bulk dir : files ;            populate directory with many files
# Cc obj.o : source.c ;         .c -> .o
# C++ obj.o : source.cc ;       .cc -> .o
# Clean clean : sources ;       remove sources with 'jam clean'
# File dest : source ;          copy file
# GenFile source.c : program args ; make custom file
# HardLink target : source ;        make link from source to target
# HdrRule source : headers ;        handle #includes
# Library lib : source ;        archive library from compiled sources
# LibraryFromObjects lib : objects ;    archive library from objects
# LinkLibraries images : libraries ;    bag libraries onto Mains
# Main image : source ;         link executable from compiled sources
# MainFromObjects image : objects ; link executable from objects
# MkDir dir ;               make a directory, if not there
# Object object : source ;      compile object from source
# ObjectCcFlags source : flags ;    add compiler flags for object
# ObjectC++Flags source : flags ;   add compiler flags for object
# ObjectHdrs source : dirs ;        add include directories for object
# Objects sources ;         compile sources
# RmTemps target : sources ;        remove temp sources after target made
# Setuid images ;           mark executables Setuid
# SoftLink target : source ;        make symlink from source to target
# SubDir TOP d1 d2 ... ;        start a subdirectory Jamfile
# SubDirCcFlags flags ;         add compiler flags until next SubDir
# SubDirC++Flags flags ;        add compiler flags until next SubDir
# SubDirHdrs d1 d2 ... ;        add include dir until next SubDir
# SubInclude TOP d1 d2 ... ;        include a subdirectory Jamfile
# Undefines images : symbols ;      save undef's for linking
# UserObject object : source ;      handle unknown suffixes for Object
#
# Utility rules that have no side effects (not supported):
#
# FAppendSuffix f1 f2 ... : $(SUF) ;    return $(<) with suffixes
# FDirName d1 d2 ... ;          return path from root to dir
# FGrist d1 d2 ... ;            return d1!d2!...
# FGristFiles value ;           return $(value:G=$(SOURCE_GRIST))
# FGristSourceFiles value ;     return $(value:G=$(SOURCE_GRIST))
# FStripCommon v1 : v2 ;        strip common initial parts of v1 v2
# FReverse a1 a2 ... ;          return ... a2 a1
# FRelPath d1 : d2 ;            return rel path from d1 to d2
# FSubDir d1 d2 ... ;           return path to root
#

# Brief review of the jam language:
#
# Statements:
#   rule RULE - statements to process a rule
#   actions RULE - system commands to carry out target update
#
# Modifiers on actions:
#   together - multiple instances of same rule on target get executed
#          once with their sources ($(>)) concatenated
#   updated - refers to updated sources ($(>)) only
#   ignore - ignore return status of command
#   quietly - don't trace its execution unless verbose
#   piecemeal - iterate command each time with a small subset of $(>)
#   existing - refers to currently existing sources ($(>)) only
#   bind vars - subject to binding before expanding in actions
#
# Special rules:
#   Always - always build a target
#   Depends - builds the dependency graph
#   Echo - blurt out targets on stdout
#   Exit - blurt out targets and exit
#   Includes - marks sources as headers for target (a codependency)
#   NoCare - don't panic if the target can't be built
#   NoUpdate - create the target if needed but never update it
#   NotFile - ignore the timestamp of the target (it's not a file)
#   Temporary - target need not be present if sources haven't changed
#
# Special variables set by jam:
#   $(<) - targets of a rule (to the left of the :)
#   $(>) - sources of a rule (to the right of the :)
#   $(xxx) - true on xxx (UNIX, VMS, NT, OS2, MAC)
#   $(OS) - name of OS - varies wildly
#   $(JAMVERSION) - version number (3.0)
#
# Special variables used by jam:
#   SEARCH - where to find something (used during binding and actions)
#   LOCATE - where to plop something not found with SEARCH
#   HDRRULE - rule to call to handle include files
#   HDRSCAN - egrep regex to extract include files
#   HCACHEFILE - name of the header dependency cache
#   HCACHEMAXAGE - maximum age a cache entry can have before it is purged
#
# Special targets:
#   all - default if none given on command line
#


#========================================================================
# rule Split STRINGS : SPLIT_CHARACTERS
#========================================================================
#
# Splits each of the STRINGS at SPLIT_CHARACTERS. All splits are
# returned as a string list.
#
# Parameters:
#    STRINGS 	        The list of strings to split at the points specified by SPLIT_CHARACTERS.
#    SPLIT_CHARACTERS   One or more characters to split the list of
#                       STRINGS at. If the string starts with % the
#                       number afterward is converted to the following
#                       ascii character code.
#                       The Strings %t, %n and %r are converted to
#                       their matching ascii code.
#                       %nl Split at any new line character
#                       %s Space or tab character
#                       %w Split at any new line, space or tab character
#

#========================================================================
# rule Bash COMMANDS ;
#========================================================================
#
# The Bash rule is used to execute one or more COMMANDS and return
# the output to the user. Each command specified in the COMMANDS list
# is executed immediately, one after another. The results of a command
# execution are returned to the caller.
#
# Parameters:
#   COMMANDS 	A list of one or more commands, each executed serially.
#
#>> # Copy file1.txt to file2.txt, ignoring output.
#>> Bash "cp file1.txt file2.txt" ;
#>>
#>> # Grab a directory listing.
#>> dir_listing = [ Bash ls ] ;
#>>
#>> # Grab two directory listings.
#>> dir_listings = [ Bash "ls *.tga" "ls *.png" ]
#>> Echo dir *.tga - $(dir_listings[1]) ;
#>> Echo dir *.png - $(dir_listings[2]) ;
#

#========================================================================
# rule Match REGEXPS : LIST ;
#========================================================================
# Matches the egrep(1) style regular expressions REGEXPS against the
# strings in LIST. The result is the concatenation of matching ()
# subexpressions for each string in LIST, and for each regular
# expression in REGEXPS. Only useful within the [ ] construct, to
# change the result into a list.

#========================================================================
# rule Math LEFT OPERATOR RIGHT ;
#========================================================================
# Calculates the result of the simple math equation of the form LEFT
# OPERATOR RIGHT. Useful only within the [ ] construct, to change the
# result into a list.
# - Parameters:
#     LEFT  	An integer for the left side of the equation.
#     OPERATOR 	+ for addition, - for subtraction, * for multiplication, / for division, and % for modulus.
#     RIGHT 	An integer for the right side of the equation.
# - Returns:
#     Returns the result of the equation.

#========================================================================
# rule Subst LIST : PATTERN [ : REPL [ : MAXN ] ] ;
#========================================================================
# Note: The Subst rule comes from the Lua code base's implementation
#       of string.gsub. The documentation below is near verbatim from
#       the Lua manual.
#
# Returns a copy of LIST in which all occurrences of the PATTERN have
# been replaced by a replacement string specified by REPL. Only useful
# within the [ ] construct, to change the result into a list.
#
# The character % works as an escape character: any sequence in repl
# of the form n, with n between 1 and 9, stands for the value of the
# n-th captured substring (see below). The sequence 0 stands for the
# whole match. The sequence %% stands for a single %.
#
# The optional last parameter n limits the maximum number of
# substitutions to occur. For instance, when n is 1 only the first
# occurrence of pattern is replaced.
#
# Parameters:
#
#    	LIST: The list of strings to apply the regular expression
#    	       substitution algorithm to.
#
#    	PATTERN: The regular expression pattern to search for within
#    	         LIST. If the pattern is found, it is replaced with REPL.
#
#    	REPL: (optional) If specified, any patterns matched with
#    	      PATTERN are replaced with the contents of REPL. If not
#    	      specified, the replacement string is empty.
#
#    	MAXN: (optional) The maximum number of substitutions to occur.
#
#>> # __/__/dir/__/dir2
#>> Echo [ Subst ../../dir/../dir2 : %.%. : __ ] ;
#>>
#>> # hello hello world world
#>> Echo [ Subst "hello world" : "(%w+)" : "%1 %1" ] ;
#>>
#>> # hello hello world
#>> Echo [ Subst "hello world" : "%w+" : "%0 %0" : 1 ] ;
#>>
#>> # world hello Lua from
#>> Echo [ Subst "hello world from Lua" : "(%w+)%s*(%w+)" : "%2 %1" ] ;
#
# Patterns
# Character Class:
#
# A character class is used to represent a set of characters. The
# following combinations are allowed in describing a character class:
#
#    x: (where x is not one of the magic characters ^$()%.[]*+-?) represents the character x itself.
#
#    .: (a dot) represents all characters.
#
#    a: represents all letters.
#
#    c: represents all control characters.
#
#    d: represents all digits.
#
#    l: represents all lowercase letters.
#
#    p: represents all punctuation characters.
#
#    s: represents all space characters.
#
#    u: represents all uppercase letters.
#
#    w: represents all alphanumeric characters.
#
#    x: represents all hexadecimal digits.
#
#    z: represents the character with representation 0.
#
#    %x: (where x is any non-alphanumeric character) represents the
#        %character x. This is the standard way to escape the magic
#        %characters. Any punctuation character (even the non magic)
#        %can be preceded by a '%' when used to represent itself in a
#        %pattern.
#
#    [set]: represents the class which is the union of all characters
#           in set. A range of characters may be specified by
#           separating the end characters of the range with a '-'. All
#           classes %x described above may also be used as components
#           in set. All other characters in set represent
#           themselves. For example, [w_] (or [_w]) represents all
#           alphanumeric characters plus the underscore,
#
#    [0-7] represents the octal digits, and [0-7l-] represents the
#          octal digits plus the lowercase letters plus the '-'
#          character.
#
#    The interaction between ranges and classes is not
#    defined. Therefore, patterns like [a-z] or [a-%%] have no
#    meaning.
#
#    [^set]: represents the complement of set, where set is interpreted as above.
#
# For all classes represented by single letters (a, c, etc.), the
# corresponding uppercase letter represents the complement of the
# class. For instance, S represents all non-space characters.
#
# The definitions of letter, space, and other character groups depend
# on the current locale. In particular, the class [a-z] may not be
# equivalent to l.
#
# Pattern Item: A pattern item may be
#
#     a single character class, which matches any single character in the class;
#
#     a single character class followed by '*', which matches 0 or
#     more repetitions of characters in the class. These repetition
#     items will always match the longest possible sequence;
#
#     a single character class followed by '+', which matches 1 or
#     more repetitions of characters in the class. These repetition
#     items will always match the longest possible sequence;
#
#     a single character class followed by '-', which also matches 0
#     or more repetitions of characters in the class. Unlike '*',
#     these repetition items will always match the shortest possible
#     sequence;
#
#     a single character class followed by '?', which matches 0 or 1
#     occurrence of a character in the class;
#
#     %n, for n between 1 and 9; such item matches a substring equal
#     %to the n-th captured string (see below);
#
#     bxy, where x and y are two distinct characters; such item
#     matches strings that start with x, end with y, and where the x
#     and y are balanced. This means that, if one reads the string
#     from left to right, counting +1 for an x and -1 for a y, the
#     ending y is the first y where the count reaches 0. For instance,
#     the item b() matches expressions with balanced parentheses.
#
# Pattern:
#
#     A pattern is a sequence of pattern items. A '^' at the beginning
#     of a pattern anchors the match at the beginning of the subject
#     string. A '$' at the end of a pattern anchors the match at the
#     end of the subject string. At other positions, '^' and '$' have
#     no special meaning and represent themselves.  Captures:
#
#     A pattern may contain sub-patterns enclosed in parentheses; they
#     describe captures. When a match succeeds, the substrings of the
#     subject string that match captures are stored (captured) for
#     future use. Captures are numbered according to their left
#     parentheses. For instance, in the pattern "(a*(.)%w(%s*))", the
#     part of the string matching "a*(.)%w(%s*)" is stored as the
#     first capture (and therefore has number 1); the character
#     matching "<code>.</code>" is captured with number 2, and the
#     part matching "<code>%s*</code>" has number 3.
#
#     As a special case, the empty capture () captures the current
#     string position (a number). For instance, if we apply the
#     pattern "()aa()" on the string "flaaap", there will be two
#     captures: 3 and 5.
#
#     A pattern cannot contain embedded zeros. Use z instead.
#

#----------------------------------------------------------------------
#     OS Specific
#----------------------------------------------------------------------

# the OS envvar is declared by Xcode in OSX, so we override it here
if $(OS) = MACOS {
  OS = MACOSX ;
}

#----------------------------------------------------------------------
#     Basic variables
#----------------------------------------------------------------------
# Logging level
# 0 - Debug
# 1 - Verbose
# 2 - Info
# 3 - Warnings
# 4 - Errors
LOG ?= 2 ;

LINT ?= 0 ;

if $(FLYMAKE) = 1 {
  FLYMAKE_PCH ?= 0 ;
  ECHO "I/Flymake build" ;
}

if $(LINT_C) && $(LINT_H) {
  # CAN_LINT = 1 ;
  CAN_LINT = 0 ; # Lint breaks Flymake for Android build...
}
if ( $(FLYMAKE) = 1 ) && ( $(CAN_LINT) = 1 ) {
  LINT_OBJECTS = 1 ;
}

#----------------------------------------------------------------------
#     Logging
#----------------------------------------------------------------------
rule logGetLoc {
  if ! $(SUBDIR_TOKENS) {
    if $(TK_NAME) {
      return "$(TK_NAME)/UNKNOWN_LOC" ;
    }
    else {
      return "UNKNOWN_LOC" ;
    }
  }
  return [ FDirName $(SUBDIR_TOKENS) ] ;
}

rule logDebug {
  if $(LOG) <= 0 {
    local _loc = [ logGetLoc ] ;
    ECHO "D/$(_loc):" $(<) ;
  }
}

rule logVerbose {
  if $(LOG) <= 1 {
    local _loc = [ logGetLoc ] ;
    ECHO "V/$(_loc):" $(<) ;
  }
}

rule logInfo {
  if $(LOG) <= 2 {
    local _loc = [ logGetLoc ] ;
    ECHO "I/$(_loc):" $(<) ;
  }
}

rule logWarn {
  if $(LOG) <= 3 {
    local _loc = [ logGetLoc ] ;
    ECHO "W/$(_loc):" $(<) ;
  }
}

rule logError {
  if $(LOG) <= 4 {
    local _loc = [ logGetLoc ] ;
    ECHO "E/$(_loc):" $(<) ;
  }
}

LOG_FATAL_EXIT ?= 1 ;
rule logFatal {
  local _loc = [ logGetLoc ] ;
  if $(LOG_FATAL_EXIT) = 1 {
    EXIT "F/$(_loc):" $(<) ;
  }
  else {
    ECHO "F/$(_loc):" $(<) ;
  }
}

rule logVar {
  logDebug $(<) "=" $($(<)) ;
}

#----------------------------------------------------------------------
#     Asserts
#----------------------------------------------------------------------
rule AssertEq {
  if $(<) != $(>) {
    logFatal "AssertEq:" $(<) "!=" $(>) ;
  }
}

rule AssertNEq {
  if $(<) = $(>) {
    logFatal "AssertNEq:" $(<) "==" $(>) ;
  }
}

rule AssertVarDefined {
  if ! $($(<)) {
    logFatal "AssertVarDefined:" $(<) "variable should be defined." ;
  }
}

rule AssertVarUndefined {
  if $($(<)) {
    logFatal "AssertVarUndefined:" $(<) "variable should not be defined." ;
  }
}

rule AssertUnreachable {
  logFatal "AssertUnreachable: code should not be reached:" $(<) ;
}

# AssertFExists CONTEXT_NAME : FILES ;
rule AssertFExists {
  if ! $(1) {
    logFatal "AssertFExists: CONTEXT_NAME not specified." ;
  }
  if ! $(2) {
    logFatal "AssertFExists: FILE not specified." ;
  }
  for _s in $(2) {
    if ! [ FExists $(_s) ] {
      logFatal "AssertFExists: $(1): Can't find '$(_s)'." ;
    }
  }
  return $(2) ;
}

# AssertFDirName CONTEXT_NAME : PATH ;
rule AssertFDirName {
  if ! $(1) {
    logFatal "AssertFDirName: CONTEXT_NAME not specified." ;
  }
  if ! $(2) {
    logFatal "AssertFDirName: PATH not specified." ;
  }
  local path = [ FDirName $(2) ] ;
  if ! [ FExists $(path) ] {
    logFatal "AssertFDirName: $(1): Can't find '$(path)'." ;
  }
  return $(path) ;
}

#----------------------------------------------------------------------
#     Import rules
#----------------------------------------------------------------------
rule ImportBuildPath {
  if [ FExists $(<) ] {
    return $(<) ;
  }

  PATH = $(HAM_HOME)/rules/$(<) ;
  if ! [ FExists $(PATH) ] {
    if $(>) {
      EXIT "ImportBuildPath:" $(>) ;
    }
    else {
      EXIT "ImportBuildPath: E/Can't find import:" $(PATH) ;
    }
  }

  return $(PATH) ;
}

rule ImportIsImported {
  if ! $(IMPORTED_$(<)) {
    return ;
  }
  return 1 ;
}

rule ImportMarkImported {
  IMPORTED_$(<) = 1 ;
}

rule Import {
  PATH = [ ImportBuildPath $(<) ] ;
  if [ ImportIsImported $(PATH) ] {
    if $(LOG) <= 0 {
      ECHO "D/ Already imported: " $(PATH) ;
    }
  }
  else {
    if $(LOG) <= 0 {
      ECHO "D/ Importing:" $(PATH) ;
    }
    ImportMarkImported $(PATH) ;
    include $(PATH) ;
  }
}

#----------------------------------------------------------------------
#     Pre-requisit utilities
#----------------------------------------------------------------------
rule FDirName
{
  # Turn individual elements in $(<) into a usable path.

  local _i ;
  local _s = $(DOT) ;
  # So that FDirName works when used in the base-*.ham files which doesnt have
  # the default definition of $(DOT) yet.
  if ! $(_s) {
    _s = . ;
  }

  for _i in $(<)
  {
    _s = $(_i:R=$(_s)) ;
  }

  return $(_s) ;
}

rule FGristDirName
{
  return [ FGristFiles [ FDirName $(<) ] ] ;
}

rule FQuote {
  if $(<) {
    return "\"$(<)\"" ;
  }
  else {
    return "\"\"" ;
  }
}

rule FQuoteFlag {
  if $(>) {
    return $(<)"\"$(>)\"" ;
  }
  else {
    return "\"\"" ;
  }
}

rule FQuoteDirName {
  return [ FQuote [ FDirName $(<) ] ] ;
}

#----------------------------------------------------------------------
#     Toolset
#----------------------------------------------------------------------
HAM_TARGET_BIN_LOA ?= $(HAM_BIN_LOA) ;
# ECHO "I/HAM_TARGET_BIN_LOA:" $(HAM_TARGET_BIN_LOA) ;
switch $(HAM_TARGET_BIN_LOA) {
  case nt-x86 : TARGET_OS = NT ; TARGET_OSPLAT = X64 ;
  case lin-x64 : TARGET_OS = LINUX ; TARGET_OSPLAT = X64 ;
  case osx-x64 : TARGET_OS = MACOSX ; TARGET_OSPLAT = X64 ;
  case osx-arm64 : TARGET_OS = MACOSX ; TARGET_OSPLAT = ARM64 ;
  case web-js : TARGET_OS = WEB ; TARGET_OSPLAT = JS ;
  case ios-arm64 : TARGET_OS = IOS ; TARGET_OSPLAT = ARM64 ;
  case * :
    EXIT "F/HAM_TARGET_BIN_LOA not supported:" $(HAM_TARGET_BIN_LOA) ;
}
TARGET_OS_FULL = $(TARGET_OS)-$(TARGET_OSPLAT) ;

if ! $(HAM_CPP_TOOLSET) {
  EXIT "F/HAM_CPP_TOOLSET not set." ;
}
Import base-$(HAM_CPP_TOOLSET).ham ;

#----------------------------------------------------------------------
#     General defaults; a lot like UNIX
#----------------------------------------------------------------------
PREFIXDLL ?= "" ;
DLLIMPLIB ?= ;
SUFDLLOBJ ?= $(SUFOBJ) ;
SUFDLL    ?= $(SUFLIB) ;

C++VERSION ?= c++17 ;
AR      ?= ar -rcs ;
AS      ?= as ;
ASFLAGS     ?= ;
YASM    ?= nasm ;
YASMFLAGS    ?= ;
AWK     ?= awk ;
BINDIR      ?= /usr/local/bin ;
C++     ?= cc ;
C++FLAGS    ?= ;
CC      ?= cc ;
CCFLAGS     ?= ;
CP      ?= cp -f ;
CP_PRESERVE ?= $(CP) -p ;
CRELIB      ?= ;
DOT     ?= . ;
DOTDOT      ?= .. ;
EXEMODE     ?= 711 ;
FILEMODE    ?= 644 ;
ROMODE      ?= 444 ;
HDRS        ?= ;
INSTALLGRIST    ?= installed ;
JAMFILE     ?= _build.ham ;
JAMRULES    ?= _rules.ham ;
LIBDIR      ?= /usr/local/lib ;
LINK        ?= $(CC) ;
LINKFLAGS   ?= ;
LINKLIBS    ?= ;
SYSTEM_LINKLIBS ?= ;
LN      ?= ln ;
MANDIR      ?= /usr/local/man ;
MKDIR       ?= mkdir -p ;
MV      ?= mv -f ;
OPTIM       ?= ;
RCP     ?= rcp ;
RM      ?= rm -f ;
RMDIR       ?= $(RM) ;
RSH     ?= rsh ;
SED     ?= sed ;
SLASH       ?= / ;
QUOTE       ?= "\"" ;
SUBDIRRULES     ?= ;
SUBDIRRESET     ?= ASFLAGS YASMFLAGS HDRS C++FLAGS CCFLAGS ;
SUFEXE      ?= "" ;
SUFLIB      ?= .a ;
SUFOBJ      ?= .o ;
UNDEFFLAG   ?= "-u _" ;
RCFLAGS     ?= ;
SUFJAVAC    ?= .class ;
if $(OS) = NT {
  HAM_EXEC_RETRY ?= ham-exec-retry ;
}
else {
  HAM_EXEC_RETRY ?= ;
}

HDRPATTERN =
"^[ 	]*#[ 	]*include[ 	]*[<\"]([^\">]*)[\">].*$" ;

if ! $(OSPLAT) {
  if $(HAM_BIN_LOA) = osx-x64 ||
     $(HAM_BIN_LOA) = nt-x86 ||
     $(HAM_BIN_LOA) = lin-x64
  {
    OSPLAT = X64 ;
  }
  else if $(HAM_BIN_LOA) = osx-arm64 ||
          $(HAM_BIN_LOA) = nt-arm64 ||
          $(HAM_BIN_LOA) = lin-arm64
  {
    OSPLAT = ARM64 ;
  }
  else {
    EXIT "E/OSPLAT not defined and unsupported HAM_BIN_LOA." ;
  }
}

OSFULL = $(OS)$(OSVER)$(OSPLAT) $(OS)$(OSPLAT) $(OS)$(OSVER) $(OS) ;

#
# Base dependencies - first for "bootstrap" kinds of rules
#

Depends all : files lib exe obj beam ;
Depends all files lib exe obj beam : first ;
NotFile all first files lib exe obj beam dirs clean uninstall ;
Always  clean uninstall ;

#
# Rules
#

# /As object : source ;
#
# Assemble (.s) the file _source_, called by the @Object rule.
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule As
{
  Depends $(<) : $(>) ;
  ASFLAGS on $(<) += $(ASFLAGS) $(SUBDIRASFLAGS) ;
  ASHDRS on $(<) = [ FIncludes $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ] ;
}

# /Yasm object : source ;
#
# Assemble (.asm) the file _source_, called by the @Object rule.
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule Yasm
{
  Depends $(<) : $(>) ;
  YASMFLAGS on $(<) += $(YASMFLAGS) $(SUBDIRYASMFLAGS) ;
  YASMHDRS on $(<) = [ FIncludesDash $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ] ;
  YASMDEFS on $(<) = [ on $(<) FDefinesDash $(DEFINES) ] ;
}

rule Masm
{
  Depends $(<) : $(>) ;
}

# /Bulk  directory : sources ;
#
# Copies _sources_ into _directory_
#
rule Bulk
{
  local i ;

  for i in $(>)
  {
    File $(i:D=$(<)) : $(i) ;
  }
}

# /Cc object : source ;
#
# Compile the file source into object, using the C compiler $(CC), its
# flags $(CCFLAGS) and $(OPTIM), and the header file directories $(HDRS).
# Called by the @Object rule
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule Cc
{
  Depends $(<) : $(>) ;

  # If the compiler's -o flag doesn't work, relocate the .o
  if $(RELOCATE)
  {
    CcMv $(<) : $(>) ;
  }

  # Just to clarify here: this sets the per-target CCFLAGS to
  # be the current value of (global) CCFLAGS and SUBDIRCCFLAGS.
  # CCHDRS and CCDEFS must be reformatted each time for some
  # compiles (VMS, NT) that malign multiple -D or -I flags.

  CCFLAGS on $(<) += $(CCFLAGS) $(SUBDIRCCFLAGS) ;

  CCHDRS on $(<) = [ on $(<) FIncludes $(HDRS) ] ;
  CCDEFS on $(<) = [ on $(<) FDefines $(DEFINES) ] ;

  # NOTE: this only works under GENERATE_CMD_JSON flag to create command json only, on impact with other build setup
  if $(GENERATE_CMD_JSON) {
    if ! [ FExists $(GENERATE_CMD_JSON) ] {
      FEcho $(GENERATE_CMD_JSON) : "" : create nl ;
    }
    local HEADERS = [ FIncludesDash [ on $(<) FGetAbsolutePath $(HDRS) ] ] ;
    local DEFINES = [ FDefinesDash $(DEFINES) ] ;
    local INPUT = [ FGetAbsolutePath [ FDirName $(SUBDIR) $(>:G=) ] ] ;
    local OUTPUT = [ FDirName $(SUBDIR) $(<:G=) ] ;
    local COMMAND = "$(CMD_JSON_COMPILER_PATH)$(CC)" "$(C++FLAGS)" "$(OPTIM)" $(DEFINES) $(HEADERS) -o "$(OUTPUT)" -c "$(INPUT)" ;
    local COMMAND = $(COMMAND:J=" ") ;

    # ECHO "COMMAND:" $(PWD) ;
    FEcho $(GENERATE_CMD_JSON) : "{" : nl ;
    FEcho $(GENERATE_CMD_JSON) : "  \"directory\": \"$(OBJDIR:P=)\"," : nl ;
    FEcho $(GENERATE_CMD_JSON) : "  \"command\": \"$(COMMAND)\"," : nl ;
    FEcho $(GENERATE_CMD_JSON) : "  \"file\": \"$(INPUT)\"" : nl ;
    FEcho $(GENERATE_CMD_JSON) : "}," : nl ;
  }
}

# /C99 object : source ;
#
# Compile the C99 source file _source_. Similar to @CC, called by @Object
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule C99
{
  Depends $(<) : $(>) ;

  if $(RELOCATE) {
    CcMv $(<) : $(>) ;
  }

  CCFLAGS on $(<) += $(CCFLAGS) $(SUBDIRCCFLAGS) ;
  C99FLAGS on $(<) += $(C99FLAGS) $(SUBDIRC99FLAGS) ;

  CCHDRS on $(<) = [ on $(<) FIncludes $(HDRS) ] ;
  CCDEFS on $(<) = [ on $(<) FDefines $(DEFINES) ] ;

  # NOTE: this only works under GENERATE_CMD_JSON flag to create command json only, on impact with other build setup
  if $(GENERATE_CMD_JSON) {
    if ! [ FExists $(GENERATE_CMD_JSON) ] {
      FEcho $(GENERATE_CMD_JSON) : "" : create nl ;
    }
    local HEADERS = [ FIncludesDash [ on $(<) FGetAbsolutePath $(HDRS) ] ] ;
    local DEFINES = [ FDefinesDash $(DEFINES) ] ;
    local INPUT = [ FGetAbsolutePath [ FDirName $(SUBDIR) $(>:G=) ] ] ;
    local OUTPUT = [ FDirName $(SUBDIR) $(<:G=) ] ;
    local COMMAND = "$(CMD_JSON_COMPILER_PATH)$(CC)" "$(C++FLAGS)" "$(OPTIM)" $(DEFINES) $(HEADERS) -o "$(OUTPUT)" -c "$(INPUT)" ;
    local COMMAND = $(COMMAND:J=" ") ;
    # ECHO "COMMAND:" $(PWD) ;
    FEcho $(GENERATE_CMD_JSON) : "{" : nl ;
    FEcho $(GENERATE_CMD_JSON) : "  \"directory\": \"$(OBJDIR:P=)\"," : nl ;
    FEcho $(GENERATE_CMD_JSON) : "  \"command\": \"$(COMMAND)\"," : nl ;
    FEcho $(GENERATE_CMD_JSON) : "  \"file\": \"$(INPUT)\"" : nl ;
    FEcho $(GENERATE_CMD_JSON) : "}," : nl ;
  }
}

# /C++ object : source ;
#
# Compile the C++ source file _source_. Similar to @CC, called by @Object
#
# Do not call this rule directly, since _object_ and _source_ may have
# platform-specific file extensions
#
rule C++
{
  Depends $(<) : $(>) ;

  if $(RELOCATE)
  {
    CcMv $(<) : $(>) ;
  }

  C++FLAGS on $(<) += $(C++FLAGS) $(SUBDIRC++FLAGS) ;

  CCHDRS on $(<) = [ on $(<) FIncludes $(HDRS) ] ;
  CCDEFS on $(<) = [ on $(<) FDefines $(DEFINES) ] ;

  # NOTE: this only works under GENERATE_CMD_JSON flag to create command json only, on impact with other build setup
  if $(GENERATE_CMD_JSON) {
    if ! [ FExists $(GENERATE_CMD_JSON) ] {
      FEcho $(GENERATE_CMD_JSON) : "" : create nl ;
    }
    local HEADERS = [ FIncludesDash [ on $(<) FGetAbsolutePath $(HDRS) ] ] ;
    local DEFINES = [ FDefinesDash $(DEFINES) ] ;
    local INPUT = [ FGetAbsolutePath [ FDirName $(SUBDIR) $(>:G=) ] ] ;
    local OUTPUT = [ FDirName $(SUBDIR) $(<:G=) ] ;
    local COMMAND = "$(CMD_JSON_COMPILER_PATH)$(C++)" "$(C++FLAGS)" "$(OPTIM)" $(DEFINES) $(HEADERS) -o "$(OUTPUT)" -c "$(INPUT)" ;
    local COMMAND = $(COMMAND:J=" ") ;
    # ECHO "COMMAND:" $(PWD) ;
    FEcho $(GENERATE_CMD_JSON) : "{" : nl ;
    FEcho $(GENERATE_CMD_JSON) : "  \"directory\": \"$(OBJDIR:P=)\"," : nl ;
    FEcho $(GENERATE_CMD_JSON) : "  \"command\": \"$(COMMAND)\"," : nl ;
    FEcho $(GENERATE_CMD_JSON) : "  \"file\": \"$(INPUT)\"" : nl ;
    FEcho $(GENERATE_CMD_JSON) : "}," : nl ;
  }
}

# /Chmod target ;
#
# (Unix and VMS only). Change file permissions on _target_ to target-specific
# $(MODE) value set by Link and File rules
#
rule Chmod
{
  if $(CHMOD) { Chmod1 $(<) ; }
}

# /Clean  clean : targets ;
#
# Removes existing _targets_ when _clean_ is built. clean is not a dependency
# of all, and must be built explicitely for targets to be removed
#

# /File target : source ;
#
# Copies _source_ into _target_
#
rule File
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  MODE on $(<) = $(FILEMODE) ;
  Chmod $(<) ;
}

# Same as file, but preserve time and attributes of the file
rule FilePreserve
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  MODE on $(<) = $(FILEMODE) ;
  Chmod $(<) ;
}

rule FilePreserveRO
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  MODE on $(<) = $(ROMODE) ;
  Chmod $(<) ;
}

rule FilePreserveEXE
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  MODE on $(<) = $(EXEMODE) ;
  Chmod $(<) ;
}

# Straight copy
rule Cp
{
  Depends $(<) : $(>) ;
}

# /GenFile target : image sources ;
#
# Runs the command "_image_ _target_ _sources_" to create _target_ from
# _sources_ and _image_ (where _image_ is an executable built by the
# @Main rule)
#
rule GenFile
{
  local _t = [ FGristSourceFiles $(<) ] ;
  local _s = [ FAppendSuffix $(>[1]) : $(SUFEXE) ] ;
  Depends $(_t) : $(_s) $(>[2-]) ;
  GenFile1 $(_t) : $(_s) $(>[2-]) ;
  Clean clean : $(_t) ;
}

rule GenFile1
{
  MakeLocate $(<) : $(LOCATE_SOURCE) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

# /HardLink target : source ;
#
# Makes _target_ a hard link to _source_, if it isn't one already
# (Unix only)
#
rule HardLink
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

# /HdrMacroFile
#
# this rule is specific to FT-Jam. It is used to indicate that a given file
# contains definitions for filename macros (e.g. "#define MYFILE_H <myfile>.h")
# that can later be used in #include statements in the rest of the source
#
# these files must be parsed before any make is tried.
#
rule HdrMacroFile
{
  HDRMACRO $(<) ;
}

# /HdrRule source : headers ;
#
# Arranges the proper dependencies when the file _source_ includes the files
# _headers_ through the #include C preprocessor directive
#
# this rule is not intendend to be called explicitely. It is called
# automatically during header scanning on sources handled by the @Object
# rule (e.g. sources in @Main or @Library rules)
#
rule HdrRule
{
  # HdrRule source : headers ;

  # N.B.  This rule is called during binding, potentially after
  # the fate of many targets has been determined, and must be
  # used with caution: don't add dependencies to unrelated
  # targets, and don't set variables on $(<).

  # Tell Jam that anything depending on $(<) also depends on $(>),
  # set SEARCH so Jam can find the headers, but then say we don't
  # care if we can't actually find the headers (they may have been
  # within ifdefs),

  # ECHO "... HdrRule: " $(<) "::" $(>) ;

  local s = $(>:G=$(HDRGRIST:E)) ;
  local t = $(HDRSEARCH) ;
  t += $(DEPHDRS) ;
  # ECHO "... -> t: " $(t) ;

  Includes $(<) : $(s) ;
  SEARCH on $(s) = $(HDRSEARCH) ;
  NoCare $(s) ;

  # Propagate on $(<) to $(>)

  #   local t = $(HDRSEARCH) ;
  #   Echo "MYHDR([$(<:D)]-[$(>:D)]): " $(HDRSEARCH) ;
  #   for _i in $(HDRSEARCH) {
    # 	t += [ FDirName $(_i) $(<:D) ] ;
    # 	t += [ FDirName $(_i) $(>:D) ] ;
  #   }
  t += $(HDROPENED:DC) ;
  # ECHO "... -> HDROPENED: " $(HDROPENED) ;

  HDRSEARCH on $(s) = $(t) ;
  HDRSCAN on $(s) = $(HDRSCAN) ;
  HDRRULE on $(s) = $(HDRRULE) ;
  HDRGRIST on $(s) = $(HDRGRIST) ;
}

# /Library  library : sources : objs ;
#
#  Compiles _sources_ and archives them into _library_. The intermediate
#  objects are deleted. Calles @Object and @LibraryFromObjects
#
#  If @Library is invoked with no suffix on _library_, the $(SUFLIB)
#  suffix is used
#
rule Library
{
  LibraryFromObjects $(<) : $(>:S=$(SUFOBJ)) $(3) ;
  Objects $(>) ;
}

# /SharedLibrary  library : sources : def : import : objs ;
#
# Compiles _sources_ and generates a shared _library_ (i.e. DLL on Windows,
# or shared object on Unix). Calls @SharedObjects and @SharedLibraryFromObjects
#
# If @SharedLibrary is invoked with no suffix on _library_, then
# $(SUFDLL) suffix is used
#
# _def_ is the name of the corresponding definition file used to generate
# the library on Windows and OS/2 (ignored otherwise). If undefined, it
# will default to _library_ with the .def suffix
#
# _import_ is the name of the corresponding import library for Windows
# and OS/2 platforms (ignored otherwise). If undefined, it will default
# to _library_ with the .dll.lib suffix.
#
rule SharedLibrary
{
  SharedLibraryFromObjects $(<) : $(>:S=$(SUFDLLOBJ)) $(5) : $(3) : $(4) ;
  SharedObjects            $(>) ;
}

# Same as SharedLibrary, but also output a static library along side the dll
rule SharedAndStaticLibrary
{
  SharedLibraryFromObjects $(<) : $(>:S=$(SUFDLLOBJ)) $(5) : $(3) : $(4) ;
  LibraryFromObjects $(<) : $(>:S=$(SUFOBJ)) $(5) ;
  SharedObjects $(>) ;
}

# /LibraryFromObjects library : objects ;
#
# Archives _objects_ into _library_. The _objects_ are then deleted
#
# If _library_ has no suffix, the $(SUFLIB) suffix is used
#
# Called by @Library rule. Most people should never call this rule
# directly.
#
rule LibraryFromObjects
{
  local _i _l _s ;

  # Add grist to file names

  _s = [ FGristFiles $(>) ] ;
  _l = $(<:S=$(SUFLIB)) ;

  # library depends on its member objects

  if $(DELOBJS)
  {
    Depends lib : $(_l) ;
  }
  else
  {
    Depends obj : $(_s) ;
  }

  # Set LOCATE for the library and its contents.  The bound
  # value shows up as $(NEEDLIBS) on the Link actions.
  # For compatibility, we only do this if the library doesn't
  # already have a path.

  if ! $(_l:D)
  {
    MakeLocate $(_l) $(_l)($(_s:BS)) : $(LOCATE_TARGET) ;
  }

  if ( ! $(DELOBJS) ) ||  $(NOARSCAN)
  {
    # If we can't scan the library to timestamp its contents,
    # we have to just make the library depend directly on the
    # on-disk object files.

    Depends $(_l) : $(_s) ;
  }
  else
  {
    # If we can scan the library, we make the library depend
    # on its members and each member depend on the on-disk
    # object file.

    Depends $(_l) : $(_l)($(_s:BS)) ;

    for _i in $(_s)
    {
      Depends $(_l)($(_i:BS)) : $(_i) ;
    }
  }

  Clean clean : $(_l) ;

  if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }

  Archive $(_l) : $(_s) ;

  if $(RANLIB) { Ranlib $(_l) ; }

  # If we can't scan the library, we have to leave the .o's around.

  if $(DELOBJS) && ! ( $(NOARSCAN) || $(NOARUPDATE) ) { RmTemps $(_l) : $(_s) ; }
}


# /SharedLibraryFromObjects  library : objects : def : import ;
#
# Equivalent of @LibraryFromObjects for shared libraries.
#
# Called by @SharedLibrary. Most people shouldn't call this rule
# directly
#
rule SharedLibraryFromObjects
{
  local _i _l _s ;

  # Add grist to file names

  _s = [ FGristFiles $(>) ] ;
  _l = $(<:S=$(SUFDLL)) ;

  #Echo "Library is $(_l)"    ;
  # library depends on its member objects

  if $(DELOBJS)
  {
    Depends lib : $(_l) ;
  }
  else
  {
    Depends obj : $(_s) ;
  }

  # Set LOCATE for the library and its contents.  The bound
  # value shows up as $(NEEDLIBS) on the Link actions.
  # For compatibility, we only do this if the library doesn't
  # already have a path.

  if ! $(_l:D)
  {
    MakeLocate $(_l) : $(LOCATE_TARGET) ;
  }

  # we never scan shared libraries for member objects
  Depends $(_l) : $(_s) ;

  Clean clean : $(_l) ;

  # I don't know if VMS supports shared libraries, so I prefer
  # to disable the following right now
  #
  #if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }

  if $(OS) = LINUX || $(OS) = MACOSX
  {
    DllLink $(_l) : $(_s) ;
  }
  else if $(NT)
  {
    local  _implib = $(4) ;

    _implib ?= $(_l:S=$(SUFLIB)) ;

    Clean    clean : $(_implib) ;
    Depends  lib   : $(_implib) ;

    Depends $(_implib) : $(_l) ;
    Depends $(_l)      ;

    IMPLIBNAME  on $(_l) = $(_implib) ;

    MakeLocate $(_implib)        : $(LOCATE_TARGET) ;
    MakeLocate $(_implib:S=.exp) : $(LOCATE_TARGET) ;

    SharedLink $(_l) : $(_s) : $(_implib) ;

    DllLink $(_l) : $(_s) ;
  }
  else
  {
    logFatal "SharedLibraryFromObjects: Sorry, I don't know how to make a shared library on your system" ;
  }
}

# /Link  image : objects ;
#
# Links _image_ from _objects_ and sets permissions on _image_ to
# $(EXEMODE). _image_ must be an actual filename; suffix is not
# supplied.
#
# Called by @Main, shouldn't be called by most people
#
rule Link
{
  MODE on $(<) = $(EXEMODE) ;
  Chmod $(<) ;
}

# /LinkLibraries image : libraries ;
#
# Makes _image_ depend on _libraries_ and includes them during linking
#
# _image_ may be referenced without a suffix in this rule invocation.
# @LinkLibraries supplies the suffix
#
# You should only use this rule with libraries created through the
# @Library rule. For external libraries, use something else (XXX)
#
rule LinkLibraries
{
  # make library dependencies of target
  # set NEEDLIBS variable used by 'actions Main'

  local _t = [ FAppendSuffix $(<) : $(SUFEXE) ] ;

  Depends $(_t) : $(>:S=$(SUFLIB)) ;
  NEEDLIBS on $(_t) += $(>:S=$(SUFLIB)) ;
}

# /LinkSharedLibraries image : libraries :
#
# Same as @LinkLibraries, but to link _image_ with shared libraries
# generated through the @SharedLibrary rule
#
rule LinkSharedLibraries
{
  # make library dependencies of target
  # set NEEDLIBS variable used by 'actions Main'

  local _t   = [ FAppendSuffix $(<) : $(SUFEXE) ] ;
  local _ext = $(SUFDLL) ;

  if $(NT) || $(OS2)
  {
    # on NT or OS/2, we need to link agains the import library,
    # not the DLL itself !!
    #
    _ext = $(SUFDLL)$(SUFLIB) ;
  }
  Depends $(_t) : $(>:S=$(_ext))  ;
  NEEDLIBS on $(_t) += $(>:S=$(_ext)) ;
}

# /Main image : sources : objs ;
#
# Compiles _sources_ and links them into _image_. Calls @Objects and
# @MainFromObjects.
#
# _image_ may be supplied without suffix.
#
rule Main
{
  MainFromObjects $(<) : $(>:S=$(SUFOBJ)) $(3) ;
  Objects $(>) ;
}

# /MainFromObjects image : objects ;
#
# Links _objects_ into _image_. Dependency of exe.
# @MainFromObjects provides a default suffix for _image_
#
rule MainFromObjects
{
  local _s _t ;

  # Add grist to file names
  # Add suffix to exe

  _s = [ FGristFiles $(>) ] ;
  _t = [ FAppendSuffix $(<) : $(SUFEXE) ] ;

  # so 'jam foo' works when it's really foo.exe

  if $(_t) != $(<)
  {
    Depends $(<) : $(_t) ;
    NotFile $(<) ;
  }

  # make compiled sources a dependency of target

  Depends exe : $(_t) ;
  Depends $(_t) : $(_s) ;
  MakeLocate $(_t) : $(LOCATE_TARGET) ;

  Clean clean : $(_t) ;

  # special case for stupid Borland C++, which always generates a
  # .tds file for executables, even when no debug information is needed
  #
  if $(HAM_CPP_TOOLSET) = BORLANDC {
    MakeLocate $(_t:S=.tds) : $(LOCATE_TARGET) ;
    Clean  clean : $(_t:S=.tds) ;
  }

  Link $(_t) : $(_s) ;
}

# /MakeLocate  targets : directory
#
# Creates _dir_ and causes _target_ to be built into _dir_
#
# This is done by setting the target-specific variable LOCATE
# on _targets_, and arranges with @MkDir to create the target
# directory
#
rule MakeLocate
{
  # Note we grist the directory name with 'dir',
  # so that directory path components and other
  # targets don't conflict.

  if $(>)
  {
    LOCATE on $(<) = $(>) ;
    Depends $(<) : $(>[1]:G=dir) ;
    MkDir $(>[1]:G=dir) ;
  }
}

# MakeDirForTarget TARGET : DIR
rule MakeDirForTarget
{
  # Note we grist the directory name with 'dir',
  # so that directory path components and other
  # targets don't conflict.

  if $(>)
  {
    Depends $(<) : $(>[1]:G=dir) ;
    MkDir $(>[1]:G=dir) ;
  }
}

# /MkDir  dir ;
#
# Creates _dir_ and its parent directories
#
rule MkDir
{
  # Ignore timestamps on directories: we only care if they
  # exist.

  NoUpdate $(<) ;

  # Don't create . or any directory already created.

  if $(<:G=) != $(DOT) && ! $($(<)-mkdir)
  {
    # Cheesy gate to prevent multiple invocations on same dir
    # Arrange for jam dirs
    # MkDir1 has the actions

    $(<)-mkdir = true ;
    Depends dirs : $(<) ;
    MkDir1 $(<) ;

    # Recursively make parent directories.
    # $(<:P) = $(<)'s parent, & we recurse until root

    local s = $(<:P) ;

    # Don't try to create A: or A:\ on windows

    if $(NT)
    {
      switch $(s)
      {
        case *:   : s = ;
        case *:\\ : s = ;
      }
    }

    # handle "C:", "C:/", "/cygdrive" and "/cygdrive/" in Cygwin
    if $(UNIX) && $(OS) = CYGWIN
    {
      switch $(s)
      {
        case ?:   : s = ;
        case ?:/  : s = ;
        case <dir>/cygdrive   : s = ;
        case <dir>/cygdrive/  : s = ;
      }
    }

    if $(s) = $(<)
    {
      # The parent is the same as the dir.
      # We're at the root, which some OS's can't stat, so we mark
      # it as NotFile.

      NotFile $(s) ;
    }
    else if $(s:G=)
    {
      # There's a parent; recurse.

      Depends $(<) : $(s) ;
      MkDir $(s) ;
    }
  }
}

# /Object object : source ;
#
# Compile s a single _source_ file into _object_. The @Main and @Library
# rules use it to compile sources.
#
# Causes _source_ to be scanned for #include directives and calls @HdrRule
# to make all included files dependencies of _object_.
#
# Calls one of the following rules depending on the suffix to do the
# actual compilation:
#
rule Object
{
  # locate object and search for source, if wanted
  Clean clean : $(<) ;

  MakeLocate $(<) : $(LOCATE_TARGET) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;

  # Save HDRS for -I$(HDRS) on compile.
  # We shouldn't need -I$(SEARCH_SOURCE) as cc can find headers
  # in the .c file's directory, but generated .c files (from
  # yacc, lex, etc) are located in $(LOCATE_TARGET), possibly
  # different from $(SEARCH_SOURCE).

  HDRS on $(<) = $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ;

  # handle #includes for source: Jam scans for headers with
  # the regexp pattern $(HDRSCAN) and then invokes $(HDRRULE)
  # with the scanned file as the target and the found headers
  # as the sources.  HDRSEARCH is the value of SEARCH used for
  # the found header files.  Finally, if jam must deal with
  # header files of the same name in different directories,
  # they can be distinguished with HDRGRIST.

  # $(SEARCH_SOURCE:E) is where cc first looks for #include
  # "foo.h" files.  If the source file is in a distant directory,
  # look there.  Else, look in "" (the current directory).

  HDRRULE on $(>) = HdrRule ;
  HDRSCAN on $(>) = $(HDRPATTERN) ;
  HDRSEARCH on $(>) =
  $(SEARCH_SOURCE:E) $(SUBDIRHDRS) $(HDRS) $(STDHDRS) ;

  HDRGRIST on $(>) = $(HDRGRIST) ;

  # propagate target specific-defines

  DEFINES on $(<) += $(DEFINES) ;

  local COMPILER = [ VarOnGet COMPILER : $(<) ] ;
  if $(COMPILER) {
    # ECHO "I/CUSTOM COMPILER FOR:" $(<) ":" $(COMPILER) ;
    $(COMPILER) $(<) : $(>) ;
  }
  else {
    local COMPILE_AS = [ VarOnGet COMPILE_AS : $(>) ] ;
    if ! $(COMPILE_AS) {
      COMPILE_AS = $(>:S) ;
    }

    # ECHO "COMPILE_AS:" $(>) "::" $(COMPILE_AS) ;

    # if source is not .c, generate .c with specific rule
    switch $(COMPILE_AS)
    {
      case .h   : if $(CAN_LINT) { LintH lint_h : $(>) ; }
      case .hpp : if $(CAN_LINT) { LintH lint_h : $(>) ; }
      case .asm : Yasm $(<) : $(>) ;
      case .masm : Masm $(<) : $(>) ;
      case .c :   Cc $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .m :   Cc $(<) : $(>) ;
      case .c99 : C99 $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .C :   C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .cc :  C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .cpp : C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .cxx : C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .c++ : C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .C++ : C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .mm  : C++ $(<) : $(>) ;
      case .s :
        As $(<) : $(>) ;
      case .rc :  ResourceCompiler $(<) : $(>) ;
      case .cni : Cni $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case * :    UserObject $(<) : $(>) ;
    }
  }
}

# /CompileAs sources : ext ;
#
# Compile the specified source files as if it was of the specified extension.
#
rule CompileAs
{
  COMPILE_AS on [ FGristFiles $(<) ] = $(>) ;
}

# nicc compiler
rule Cni
{
  local _h ;
  _h = [ FDirName $(SUBDIR) $(>:BS=.cni.hpp) ] ;
  local _cpp ;
  _cpp = [ FDirName $(SUBDIR) $(>:BS=.cni.cxx) ] ;

  Depends $(_cpp) $(_h) : $(>) ;
  Includes $(_cpp) : $(_h) ;
  C++ $(<) : $(_cpp) ;

  RmTemps $(<) : $(_h) $(_cpp) ;
}
actions Cni
{
  "$(NICC_EXE)" "$(>)"
}

# /ObjectOptimFlags  sources : flags ;
#
# this rule is used to add flags to the optim compilation of
# specific sources files.
#
rule ObjectOptimFlags
{
  OPTIM on [ FGristFiles $(<:S=$(SUFOBJ)) ] ?= $(OPTIM) ;
  OPTIM on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;
}

# /ObjectCcFlags  sources : flags ;
#
# this rule is used to add compiler flags to the compilation of
# specific C sources files.
#
rule ObjectCcFlags
{
  CCFLAGS on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;
}

# /ObjectC99Flags  sources : flags ;
#
# this rule is used to add compiler flags to the compilation of
# specific C sources files.
#
rule ObjectC99Flags
{
  C99FLAGS on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;
}

# /ObjectC++Flags  sources : flags ;
#
# this rule is used to add compiler flags to the compilation of
# specific C++ source files
#
rule ObjectC++Flags
{
  C++FLAGS on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;
}

# /ObjectCC++Flags sources : flags ;
rule ObjectCC++Flags
{
  ObjectCcFlags $(<) : $(>) ;
  ObjectC++Flags $(<) : $(>) ;
}

# /ObjectCompiler objects : compiler ;
rule ObjectCompiler
{
  local s = [ FGristFiles $(<:S=$(SUFOBJ)) ] ;
  COMPILER on $(s) = $(>) ;
}

# /ObjectDefines  objects : macros ;
#
# this rule is used to add macro defines to the compilation of
# specific C and C++ source files
#
rule ObjectDefines
{
  # must reformat CCDEFS according to current defines

  local s = [ FGristFiles $(<:S=$(SUFOBJ)) ] ;

  DEFINES on $(s) ?= $(DEFINES) ;
  CCDEFS on $(s) ?= $(CCDEFS) ;
  DEFINES on $(s) += $(>) ;
  CCDEFS on $(s) += [ on $(s) FDefines $(DEFINES) ] ;
}

# /ObjectHdrs  sources : paths ;
#
# this rule is used to add include paths to the compilation of
# specific C and C++ source files
#
rule ObjectHdrs
{
  # Add to HDRS for HdrScan's benefit.
  # must reformat CCHDRS according to headers

  local s = [ FGristFiles $(<:S=$(SUFOBJ)) ] ;

  HDRS on $(s) += $(>) ;
  CCHDRS on $(s) = [ on $(s) FIncludes $(HDRS) ] ;
}

# Return the suffix of the specified source file
rule FTargetSuffix
{
  switch $(<:S) {
    case .java : return $(SUFJAVAC) ;
    case .scala : return $(SUFJAVAC) ;
    case .erl :	return $(SUFBEAM) ;
    case .asm : return $(SUFOBJ) ;
    case .masm : return $(SUFOBJ) ;
    case .c : return $(SUFOBJ) ;
    case .c99 : return $(SUFOBJ) ;
    case .m : return $(SUFOBJ) ;
    case .C : return $(SUFOBJ) ;
    case .cc : return $(SUFOBJ) ;
    case .cpp : return $(SUFOBJ) ;
    case .cxx : return $(SUFOBJ) ;
    case .c++ : return $(SUFOBJ) ;
    case .C++ : return $(SUFOBJ) ;
    case .mm  : return $(SUFOBJ) ;
    case .d : return $(SUFOBJ) ;
    case .f : return $(SUFOBJ) ;
    case .s : return $(SUFOBJ) ;
    case .rc : return $(SUFOBJ) ;
    case .cni : return $(SUFOBJ) ;
    case * : return [ UserFTargetSuffix $(<) ] ;
  }
  return $(<:S) ;
}

rule UserFTargetSuffix {
  logFatal "UserFTargetSuffix: not defined for:" $(<) ;
}

rule FTarget
{
  local s = [ FTargetSuffix $(<) ] ;
  return $(<:S=$(s)) ;
}

# ObjectSuf SOURCE
# call the Object rule with the appropriate suffix, returns the name
# of the target
rule ObjectSuf
{
  local suf = [ FTargetSuffix $(<) ] ;
  local d = $(<:S=$(suf)) ;
  switch $(suf) {
    case .class :
      Object $(d) : $(_i) ;
      Depends class : $(d) ;
    case .beam :
      Object $(d) : $(_i) ;
      Depends beam : $(d) ;
    case * :
      Object $(d) : $(_i) ;
      Depends obj : $(d) ;
  }
  return $(d) ;
}

# /Objects sources ;
#
# this rule is used to compile one or more sources into object files.
# do not call it directly, it is used by the Main and Library rules
# automatically
#
rule Objects
{
  local _i ;
  local r ;

  for _i in [ FGristFiles $(<) ]
  {
    r += [ ObjectSuf $(_i) ] ;
  }

  return $(r) ;
}

# /SharedObjects
#
# this rule is used to compile one or more sources into 'shared object
# files'. This means object files used to build either DLLs or Unix shared
# libraries.
#
# do not call this rule directly, it is called by SharedLibrary automatically
#
rule SharedObjects
{
  # temporarily override SUFOBJ with $(SUFDLLOBJ) to
  #
  local SUFOBJ = $(SUFDLLOBJ) ;

  # call the normal Objects rule
  #
  Objects $(<) ;
}

rule RmTemps
{
  Temporary $(>) ;
}

rule Setuid
{
  MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4711 ;
}

rule SoftLink
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  Clean clean : $(<) ;
}

rule SubDir
{
  #
  # SubDir TOP d1 d2 ... ;
  #
  # Support for a project tree spanning multiple directories.
  #
  # SubDir declares a Jamfile's location in a project tree, setting
  # Jambase variables (SEARCH_SOURCE, LOCATE_TARGET) so that source
  # files can be found.
  #
  # TOP is a user-select variable name for root of the tree, and
  # d1 d2 ...  are the directory elements that lead from the root
  # of the tree to the directory of the Jamfile.
  #
  # TOP can be set externally, but normally the first SubDir call
  # computes TOP as the path up from the current directory; the
  # path contains one ../ for each of d1 d2 ...
  #
  # SubDir reads once the project-specific rules file Jamrules
  # in the TOP directory, if present.  This can be overridden
  # with the variable TOPRULES.
  #
  # SubDir supports multiple, overlaid project trees:  SubDir
  # invocations with different TOPs can appear in the same Jamfile.
  # The location established by the first SubDir call is used set
  # the TOPs for the subsequent SubDir calls.
  #
  # SubDir's public variables:
  #
  #   $(TOP) = path from CWD to root.
  #   $(SUBDIR) = path from CWD to the directory SubDir names.
  #   $(SUBDIR_TOKENS) = path from $(TOP) to $(SUBDIR) as dir names
  #   $(SEARCH_SOURCE) = $(SUBDIR)
  #   $(LOCATE_SOURCE) = $(ALL_LOCATE_TARGET) $(SUBDIR)
  #   $(LOCATE_TARGET) = $(ALL_LOCATE_TARGET) $(SUBDIR)
  #   $(SOURCE_GRIST) = $(SUBDIR_TOKENS) with !'s
  #

  local _top = $(<[1]) ;
  local _tokens = $(<[2-]) ;

  #
  # First time through sets up relative root and includes Jamrules.
  #

  if ! $(_top)
  {
    Exit SubDir syntax error ;
  }

  if ! $($(_top)-SET)
  {
    $(_top)-SET = true ;

    # First time we've seen this TOP.
    # We'll initialize a number of internal variables:
    #
    #   $(TOP-UP) = directories from ROOT to a common point
    #   $(TOP-DOWN) = directories from common point to TOP
    #   $(TOP-ROOT) = root directory for UP/DOWN -- normally CWD
    #   $(SUBDIR_UP) = current value of $(TOP-UP)
    #   $(SUBDIR_DOWN) = current value of $(TOP-DOWN)
    #   $(SUBDIR_ROOT) = current value of $(TOP-ROOT)
    #

    if $($(_top))
    {
      # TOP externally set.
      # We'll ignore the relative (UP/DOWN) path that
      # got us here, and instead remember the hard ROOT.

      $(_top)-UP = ;
      $(_top)-DOWN = ;
      $(_top)-ROOT = $($(_top)) ;
    }
    else
    {
      # TOP not preset.

      # Establishing a new TOP.  In the simplest case,
      # (SUBDIR_UP/SUBDIR_DOWN/SUBDIR_ROOT unset), it's
      # merely a certain number of directories down from
      # the current directory, and FSubDirPath will set
      # TOP to a path consisting of ../ for each of the
      # elements of _tokens, because that represents how
      # far below TOP the current directory sits.
      #
      # In the more complicated case, the starting directory
      # isn't the directory of jam's invocation but an
      # location established by previous SubDir call.  The
      # starting directory is SUBDIR_UP directories up from
      # SUBDIR_ROOT, and then SUBDIR_DOWN directories down
      # from that.   If SUBDIR_ROOT is not set, that means
      # SUBDIR_DOWN and SUBDIR_UP represent the path from
      # the directory of jam's invocation.
      #
      # In the most complicated case, the _tokens also
      # represents directories down, because TOP is being
      # estalished in a directory other than TOP's root.
      # Hopefully, _tokens and SUBDIR_DOWN represent the
      # same final directory, relative to the new TOP and
      # the previous SubDIr's TOP.  To find the new TOP,
      # we have to chop off any common directories from
      # then ends of _tokens and SUBDIR_DOWN.  To do so,
      # we reverse each of them, call FStripCommon to
      # remove the initial common elements, and then
      # reverse them again.  After this process, if
      # both _tokens and SUBDIR_DOWN have elements, it
      # means the directory names estalished by the two
      # SubDir calls don't match, and a warning is issued.
      # All hell will likely break loose at this point,
      # since the whole SubDir scheme relies on the SubDir
      # calls accurately naming the current directory.

      # Strip common trailing elements of _tokens and SUBDIR_DOWN.

      _tokens = [ FReverse $(_tokens) ] ;
      SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;
      FStripCommon _tokens : SUBDIR_DOWN ;
      SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;
      _tokens = [ FReverse $(_tokens) ] ;

      if $(SUBDIR_DOWN) && $(_tokens)
      {
        Echo Warning: SubDir $(<) misplaced! ;
      }

      # We'll remember the relative (UP/DOWN) path that
      # got us here, plus any hard ROOT starting point
      # for the UP/DOWN.  If TOP is never set externally,
      # ROOT will always be "" (directory of jam's invocation).

      $(_top)-UP = $(SUBDIR_UP) $(_tokens) ;
      $(_top)-DOWN = $(SUBDIR_DOWN) ;
      $(_top)-ROOT = $(SUBDIR_ROOT:E="") ;
      $(_top) = [ FSubDirPath $(_top) ] ;
    }

    # Set subdir vars for the inclusion of the Jamrules,
    # just in case they have SubDir rules of their own.
    # Note that SUBDIR_DOWN is empty: it's all the way
    # up where the Jamrules live.  These gets overrided
    # just after the inclusion.

    SUBDIR_UP = $($(_top)-UP) ;
    SUBDIR_DOWN = ;
    SUBDIR_ROOT = $($(_top)-ROOT) ;

    # Include $(TOPRULES) or $(TOP)/Jamrules.
    # Include $(TOPRULES) if set.
    # Otherwise include $(TOP)/Jamrules if present.

    if $($(_top)RULES) {
      include $($(_top)RULES) ;
    }
    else {
      NoCare $(JAMRULES:R=$($(_top)):G=$(_top)) ;
      include $(JAMRULES:R=$($(_top)):G=$(_top)) ;
    }
  }

  # Get path from $(TOP) to named directory.
  # Save dir tokens for other potential uses.

  SUBDIR_UP = $($(_top)-UP) ;
  SUBDIR_DOWN = $($(_top)-DOWN) $(_tokens) ;
  SUBDIR_ROOT = $($(_top)-ROOT) ;
  SUBDIR_TOKENS = $(SUBDIR_DOWN) ;

  SUBDIR = [ FSubDirPath $(<) ] ;

  # Now set up SEARCH_SOURCE, LOCATE_TARGET, SOURCE_GRIST
  # These can be reset if needed.  For example, if the source
  # directory should not hold object files, LOCATE_TARGET can
  # subsequently be redefined.

  SEARCH_SOURCE = $(SUBDIR) ;
  LOCATE_SOURCE = $(ALL_LOCATE_TARGET) $(SUBDIR) ;
  LOCATE_TARGET = $(ALL_LOCATE_TARGET) $(SUBDIR) ;
  SOURCE_GRIST = [ FGrist $(SUBDIR_TOKENS) ] ;

  # Reset per-directory ccflags, hdrs, etc,
  # listed in SUBDIRRESET.
  # Note use of variable expanded assignment var

  SUBDIR$(SUBDIRRESET) = ;

  # Invoke user-specific SubDir extensions,
  # rule names listed in SUBDIRRULES.
  # Note use of variable expanded rule invocation

  $(SUBDIRRULES) $(<) ;

  if ! [ FExists $(SUBDIR) ] {
    EXIT "SubDir: Can't find subdirectory: '$(SUBDIR)'" ;
  }
}

rule FSubDirPath
{
  # FSubDirPath TOP d1 ... ;

  # Returns path to named directory.

  # If jam is invoked in a subdirectory of the TOP, then we
  # need to prepend a ../ for every level we must climb up
  # (TOP-UP), and then append the directory names we must
  # climb down (TOP-DOWN), plus the named directories d1 ...
  # If TOP was set externally, or computed from another TOP
  # that was, we'll have to reroot the whole thing at TOP-ROOT.

  local _r = [ FRelPath $($(<[1])-UP) : $($(<[1])-DOWN) $(<[2-]) ] ;

  return $(_r:R=$($(<[1])-ROOT)) ;
}

rule SubDirDcFlags
{
  SUBDIRDCFLAGS += $(<) ;
}

rule SubDirCcFlags
{
  SUBDIRCCFLAGS += $(<) ;
}

rule SubDirC++Flags
{
  SUBDIRC++FLAGS += $(<) ;
}

rule SubDirCC++Flags
{
  SubDirCcFlags $(<) ;
  SubDirC++Flags $(<) ;
}

rule SubDirHdrs
{
  SUBDIRHDRS += [ FDirName $(<) ] ;
}

rule SubInclude
{
  # SubInclude TOP d1 ... ;
  #
  # Include a subdirectory's Jamfile.

  # We use SubDir to get there, in case the included Jamfile
  # either doesn't have its own SubDir (naughty) or is a subtree
  # with its own TOP.

  if ! $($(<[1]))
  {
    EXIT SubInclude '$(<[1])' without prior SubDir '$(<[1])' ;
  }

  SubDir $(<) ;

  include $(JAMFILE:D=$(SUBDIR)) ;
}

rule SubRules
{
  # SubRules TOP d1 ... : Other-TOP ;
  #
  # Read another tree's Jamrules, by giving it's path according
  # to this tree and it's own name.

  if ! $($(<[1]))
  {
    EXIT SubRules $(<[1]) without prior SubDir $(<[1]) ;
  }

  SubDir $(<) ;
  SubDir $(>) ;
}

rule Undefines
{
  UNDEFS on [ FAppendSuffix $(<) : $(SUFEXE) ] += $(UNDEFFLAG)$(>) ;
}

rule UserObject
{
  logFatal "UserObject: Unknown suffix on" $(>) "- see UserObject rule in 'base.ham'." ;
}

#
# Utility rules; no side effects on these
#

# /FGrist path to file ;
#
# Returns a single string that is used as grist
#
rule FGrist
{
  return $(<:J=!) ;

}

rule FGristFilesForDepends {
  return [ Subst [ FGristFiles $(<) ] : "%!" : "%/" ] ;
}

rule FGristFiles
{
  return $(<:G=$(SOURCE_GRIST:E)) ;
}


rule FGristSourceFiles
{
  # Produce source file name name with grist in it,
  # if SOURCE_GRIST is set.

  # Leave header files alone, because they have a global
  # visibility.

  if ! $(SOURCE_GRIST)
  {
    return $(<) ;
  }
  else
  {
    local _i _o ;

    for _i in $(<)
    {
      switch $(_i)
      {
        case *.h :  _o += $(_i) ;
        case * :    _o += $(_i:G=$(SOURCE_GRIST)) ;
      }
    }

    return $(_o) ;
  }
}

rule FReverse
{
  if $(1) { return [ FReverse $(1[2-]) ] $(1[1]) ; }
}


rule FSubDir
{
  # If $(>) is the path to the current directory, compute the
  # path (using ../../ etc) back to that root directory.
  # Sets result in $(<)

  if ! $(<[1])
  {
    return $(DOT) ;
  }
  else
  {
    local _i _d ;

    _d = $(DOTDOT) ;

    for _i in $(<[2-])
    {
      _d = $(_d:R=$(DOTDOT)) ;
    }

    return $(_d) ;
  }
}


rule FStripCommon
{
  # FStripCommon v1 : v2 ;

  # Strip common initial elements of variables v1 and v2.
  # Modifies the variable values themselves.

  if $($(<)[1]) && $($(<)[1]) = $($(>)[1])
  {
    $(<) = $($(<)[2-]) ;
    $(>) = $($(>)[2-]) ;
    FStripCommon $(<) : $(>) ;
  }
}


rule FRelPath
{
  local _l _r ;

  # first strip off common parts

  _l = $(<) ;
  _r = $(>) ;

  FStripCommon _l : _r ;

  # now make path to root and path down

  _l = [ FSubDir $(_l) ] ;
  _r = [ FDirName $(_r) ] ;

  # Concatenate and save

  # XXX This should be better

  if $(_r) = $(DOT) {
    return $(_l) ;
    } else {
      return $(_r:R=$(_l)) ;
    }
}


rule FAppendSuffix
{
  # E.g., "FAppendSuffix yacc lex foo.bat : $(SUFEXE) ;"
  # returns (yacc,lex,foo.bat) on Unix and
  # (yacc.exe,lex.exe,foo.bat) on NT.

  if $(>)
  {
    local _i _o ;

    for _i in $(<)
    {
      if $(_i:S)
      {
        _o += $(_i) ;
      }
      else
      {
        _o += $(_i:S=$(>)) ;
      }
    }
    return $(_o) ;
  }
  else
  {
    return $(<) ;
  }
}

#
# Operating system specific utility rules
# First, the (generic) UNIX versions
#

rule FDefinesDash { return -D$(<) ; }
rule FIncludesDash { return -I$(<) ; }
rule FDefinesSlash { return /D$(<) ; }
rule FIncludesSlash { return /I$(<) ; }

rule FDefines {
  return -D$(<) ;
}
rule FIncludes {
  local incdir = $(<) ;
  local absIncdir = [ FGetAbsolutePath $(<) ] ;
  return -I"\"$(absIncdir)\"" ;
}
rule FIncludesLint {
  local incdir = $(<) ;
  local absIncdir = [ FGetAbsolutePath $(<) ] ;
  return -i"\"$(absIncdir)\"" ;
}

# FOptionPath OPTION : PATH
rule FOptionPath {
  local r = ;
  for _d in $(>) {
    r += "$(<)""\"$(_d)\"" ;
  }
  return $(r) ;
}

# FOptionPathWithSpace OPTION : PATH
rule FOptionPathWithSpace {
  local r = ;
  for _d in $(>) {
    r += "$(<)" "\"$(_d)\"" ;
  }
  return $(r) ;
}

# Remove all .. and . from a list to create a "clean" list that can be used to build absolute path
rule FCleanDirs {
  local r = ;
  local prevprev = ;
  local prev = ;
  for _d in $(<) {
    if $(_d) = $(DOTDOT) {
      r = $(prev) ;
    }
    else if $(_d) = $(DOT) {
    }
    else {
      prev = $(r) ;
      r += $(_d) ;
    }
  }
  return $(r) ;
}

# Return an absolute directory path from a path which is relative to the SUBDIR
rule FSubDirAbsName {
  if ! $(TOP_DIR) {
    EXIT "FSubDirAbsName: The TOP_DIR environment variable must be set in your local _rules.ham." ;
  }

  local d = [ FCleanDirs $(SUBDIR_TOKENS) $(<) ] ;
  return [ FDirName $(TOP_DIR) $(d) ] ;
}

#
# Default actions
#
actions updated together piecemeal Archive
{
  $(AR) "$(<)" "$(>)"
}

actions As
{
  "$(AS)" $(ASFLAGS) $(ASHDRS) -o "$(<)" "$(>)"
}

actions Yasm
{
  "$(YASM)" $(YASMFLAGS) $(YASMHDRS) $(YASMDEFS) -o "$(<)" "$(>)"
}

actions Masm
{
   ml -nologo -Fo "$(<)" -c "$(>)"
}

actions Cc
{
  $(CC) -c -o "$(<)" $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) "$(>)"
}

actions C99
{
  $(CC) -c -o "$(<)" $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) "$(>)"
}

actions C++
{
  $(C++) -c -o "$(<)" $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) "$(>)"
}

rule LintC
{
  Depends $(<) : $(>) ;
  Depends lint : $(<) ;
  LINT_HDRS on $(<) = [ on $(<) FIncludesLint $(HDRS) ] ;
}
actions LintC
{
  $(LINT_C) $(LINT_HDRS) "$(>)" ; $(LINT_CANNOT_FAIL)
}

rule LintH
{
  Depends $(<) : $(>) ;
  Depends lint : $(<) ;
  LINT_HDRS on $(<) = [ on $(<) FIncludesLint $(HDRS) ] ;
}
actions LintH
{
  $(LINT_H) $(LINT_HDRS) "$(>)" ; $(LINT_CANNOT_FAIL)
}

actions Chgrp
{
  $(HAM_EXEC_RETRY) $(CHGRP) $(GROUP) "$(<)"
}

actions Chmod1
{
  $(HAM_EXEC_RETRY) $(CHMOD) $(MODE) "$(<)"
}

actions Chown
{
  $(HAM_EXEC_RETRY) $(CHOWN) $(OWNER) "$(<)"
}

actions piecemeal together existing Clean
{
  $(HAM_EXEC_RETRY) $(RM) "$(>)"
}

actions Cp
{
  $(HAM_EXEC_RETRY) $(CP) "$(>)" "$(<)"
}

rule Touch {
}
actions Touch {
  $(HAM_EXEC_RETRY) touch "$(<)"
}

actions File
{
  $(HAM_EXEC_RETRY) $(CP) "$(>)" "$(<)"
}


if $(OS) = MACOSX {
  # On macOS we have to delete the destination before copying otherwise
  # gatekeeper will think its suspicious and `Kill: 9` our processes when they
  # start.
  actions FilePreserveRO {
    rm -f "$(<)"
    $(CP_PRESERVE) "$(>)" "$(<)"
  }
  actions FilePreserveEXE {
    rm -f "$(<)"
    $(CP_PRESERVE) "$(>)" "$(<)"
  }
  actions FilePreserve {
    rm -f "$(<)"
    $(CP_PRESERVE) "$(>)" "$(<)"
  }
}
else {
  actions FilePreserveRO
  {
    $(HAM_EXEC_RETRY) $(CP_PRESERVE) "$(>)" "$(<)"
  }
  actions FilePreserveEXE
  {
    $(HAM_EXEC_RETRY) $(CP_PRESERVE) "$(>)" "$(<)"
  }
  actions FilePreserve
  {
    $(HAM_EXEC_RETRY) $(CP_PRESERVE) "$(>)" "$(<)"
  }
}

if $(UNIX) {
  actions GenFile1 {
    PATH="$PATH:."
    $(>[1]) "$(<)" "$(>[2-])"
  }
}
else {
  actions GenFile1 {
    $(>[1]) "$(<)" "$(>[2-])"
  }
}

actions HardLink
{
  $(HAM_EXEC_RETRY) $(RM) "$(<)" && $(LN) "$(>)" "$(<)"
}

actions Link bind NEEDLIBS
{
  $(LINK) $(LINKFLAGS) -o "$(<)" $(UNDEFS) "$(>)" $(NEEDLIBS) $(LINKLIBS) $(SYSTEM_LINKLIBS)
}

actions MkDir1
{
  $(MKDIR) "$(<)"
}

actions together Ranlib
{
  $(RANLIB) "$(<)"
}

actions quietly updated piecemeal together RmTemps
{
  $(HAM_EXEC_RETRY) $(RM) "$(>)"
}

actions SoftLink
{
  $(HAM_EXEC_RETRY) $(RM) "$(<)" && $(LN) -s "$(>)" "$(<)"
}

# The the absolute path of the specified path, using / as file separator
rule FGetAbsolutePath {
  local D = [ GetAbsolutePath $(1) ] ;
  return $(D:/) ;
}

# FDirNameFiles DIR : FILES
rule FDirNameFiles {
  local t ;
  for _i in $(>) {
    t += [ FDirName $(<) $(_i) ] ;
  }
  return $(t) ;
}

# MakeLocateFiles TARGET : BASE_DIR : OBJDIR : FILES
rule MakeLocateFiles {
  local fd = [ FDirName $(3) $(>) ] ;
  MakeLocate $(<) : [ FDirName $(3) $(>) ] ;
  for _f in $(4) {
    local d = $(_f:D) ;
    if $(d) {
      MakeLocate $(<) : [ FDirName $(3) $(>) $(d) ] ;
    }
  }
}

# SrcSubDir PACKAGE : d1 .. dn : OBJDIR : SRC
rule SrcSubDir
{
  SubDirHdrs $(SUBDIR) $(>) ;
  MakeLocateFiles ObjDir_$(<) : $(2) : $(3) : $(4) ;
  NotFile ObjDir_$(<) ;
  NoUpdate ObjDir_$(<) ;
  Depends $(<) : ObjDir_$(<) ;
  local s = [ FDirNameFiles $(>) : $(4) ] ;
  Depends [ FGristFiles $(s) ] : ObjDir_$(<) ;
  return $(s) ;
}

# SrcSubDirGlob PACKAGE : d1 .. dn : OBJDIR : SRC_PATTERN
rule SrcSubDirGlob
{
  local d = [ FDirName $(SUBDIR) $(>) ] ;
  local s = [ GlobSrc $(d) : $(4) ] ;
  return [ SrcSubDir $(<) : $(>) : $(3) : $(s) ] ;
}

# SrcSubDir PACKAGE : d1 .. dn : OBJDIR : SRC
rule SrcSubDirNoHdrs
{
  MakeLocateFiles ObjDir_$(<) : $(2) : $(3) : $(4) ;
  NotFile ObjDir_$(<) ;
  NoUpdate ObjDir_$(<) ;
  Depends $(<) : ObjDir_$(<) ;
  local s = [ FDirNameFiles $(>) : $(4) ] ;
  Depends [ FGristFiles $(s) ] : ObjDir_$(<) ;
  return $(s) ;
}

# SrcSubDirGlob PACKAGE : d1 .. dn : OBJDIR : SRC_PATTERN
rule SrcSubDirGlobNoHdrs
{
  local d = [ FDirName $(SUBDIR) $(>) ] ;
  local s = [ GlobSrc $(d) : $(4) ] ;
  return [ SrcSubDirNoHdrs $(<) : $(>) : $(3) : $(s) ] ;
}

# Return source files with the given extension
# REM: Excludes files starting with an underscore or a dot,
#      they are considered hidden/auto-generated.
# EXAMPLE: GlobSrc DIR : .cpp .h .asm ;
rule GlobSrcWithDir
{
  return [ GLOB [ FDirName $(<) ] : "[^_.]*"$(>) ] ;
}
rule GlobSrc
{
  local r ;
  local t = [ GlobSrcWithDir $(<) : $(>) ] ;
  for _i in $(t) {
    r += $(_i:B)$(_i:S) ;
  }
  return $(r) ;
}

# DataGlob BASEDIR : SUBDIR : EXTENSIONS
rule DataGlob {
  return [ GlobSrcWithDir [ FDirName $(1) $(2) ] : $(3) ] ;
}

# DataList BASEDIR : SUBDIR : FILES
rule DataList {
  local r = ;
  for _s in $(3) {
    r += [ FDirName $(1) $(2) $(_s) ] ;
  }
  return $(r) ;
}

# CopyDataToDir BASEDIR : FILES : DESTDIR ;
rule CopyDataToDir {
  local destDir = $(3) ;
  MkDir $(destDir) ;

  local r = ;
  for _s in $(>) {
    local s = [ StrAfterI $(_s) : "$(<)/" ] ;
    # ECHO "--[$(<)/] $(_s) -> $(s)" ;
    local dest = [ FDirName $(destDir) $(s) ] ;
    DEPENDS $(dest) : $(destDir) ;
    # ECHO "$(_s) -> $(dest)" ;
    File $(dest) : $(_s) ;
    r += $(dest) ;
  }
  return $(r) ;
}

# TargetLinkFlags TARGET : FLAGS ;
rule TargetLinkFlags
{
  LINKFLAGS on $(<) ?= $(LINKFLAGS) ;
  LINKFLAGS on $(<) += $(>) ;
}

# TargetLinkLibs TARGET : LIBS ;
rule TargetLinkLibs
{
  LINKLIBS on $(<) ?= $(LINKLIBS) ;
  for _l in $(>) {
    LINKLIBS on $(<) += $(_l) ;
  }
}

# FileExists File
# REM: Tests only the filename not the directory path
rule FileExists
{
  local f = [ GLOB "." : $(<) ] ;
  if $(f) {  return 1 ; }
  return 0 ;
}

rule TestFileExists
{
  local d = [ FDirName $(2) ] ;
  for _i in $(3) {
    local t = $(_i:B)$(_i:S) ;
    local f = [ GLOB $(d) : $(t) ] ;
    f = $(f:B)$(f:S) ;
    if ! ( $(f) = $(t) ) {
      # 	  Echo "FF: [$(f)] = [$(t)]" ;
      Exit "Test Failed : $(1) : Can't find '$(3)' in '$(d)'." ;
    }
  }
}

# Return 1 if the element has already been include, else 0
rule IncludeOnce {
  if $(NO_ONCEGUARD) { return 0 ; }
  local dir = [ FDirName $(<) ] ;
  local inList = [ ListContains $(ONCE_LIST) : $(dir) ] ;
  # ECHO "IncludeOnce=" $(inList) "-" $(dir) "?" $(ONCE_LIST) ;
  if $(inList) = 1 { return 1 ; }
  return 0 ;
}

rule SubDirOnce {
  if [ IncludeOnce $(<) ] = 1 { return 1 ; }
  ONCE_LIST += [ FDirName $(<) ] ;
  SubDir $(<) ;
  return 0 ;
}

# SrcListDeps $(SRC) : $(DEPENDENCIES)
rule SrcListDeps {
  DEPENDS [ FGristFiles $(<) ] : $(>) ;
}

# ListDirs BASEDIR : PATTERN : EXCLUDE PATTERN
rule ListDirs {
  local p ;
  if $(>) {
    p = $(>) ;
  }
  else {
    p = "*" ;
  }
  local xp = "*.." "*." "*/.." "*/." ;
  if $(3) {
    xp += $(3) ;
  }

  local r = ;
  for _i in $(<) {
    local f = [ GLOB [ FDirName $(_i) ] : $(p) ] ;
    for _f in $(f) {
      if [ FISDIR $(_f) ] && ! [ GLOBSTRING $(_f) : $(xp) ] {
        r += $(_f) ;
      }
    }
  }
  return $(r) ;
}

# ListDirsR BASEDIR : PATTERN : EXCLUDE PATTERN
# Recursively list directories INSIDE BASEDIR, doesn't list BASEDIR.
rule ListDirsR {
  local r = [ ListDirs $(<) : $(>) : $(3) ] ;
  for _d in $(r) {
    r += [ ListDirsR $(_d) : $(>) : $(3) ] ;
  }
  return $(r) ;
}

# ListFiles DIRS : PATTERN : EXCLUDE PATTERN
# Example: [ ListFiles [ ListDirsR $(SUBDIR) ] : *.c ] ] ;
rule ListFiles {
  local r ;
  local p ;
  if $(>) {
    p = $(>) ;
  }
  else {
    p = "*" ;
  }
  local xp = "*.." "*." "*/.." "*/." ;
  if $(3) {
    xp += $(3) ;
  }

  for _d in $(<) {
    local f = [ GLOB [ FDirName $(_d) ] : $(p) ] ;
    for _f in $(f) {
      local fn = $(_f:B)$(_f:S) ;
      if ! [ FISDIR $(_f) ] && ! [ GLOBSTRING $(fn) : $(xp) ] {
        r += $(_f) ;
      }
    }
  }
  return $(r) ;
}

# ListContains LIST : token
# Check whether the list contains the specified token
rule ListContains {
  for _d in $(<) {
    if $(_d) = $(>) {
      return 1 ;
    }
  }
  return ;
}

# ListAddFront LIST : token
rule ListAddFront {
  return $(>) $(<) ;
}

rule ListAddFrontOnce {
  if [ ListContains $(<) : $(>) ] {
    return $(<) ;
  }
  return [ ListAddFront $(<) : $(>) ] ;
}

# ListAddBack LIST : token
rule ListAddBack {
  return $(<) $(>) ;
}

rule ListAddBackOnce {
  if [ ListContains $(<) : $(>) ] {
    return $(<) ;
  }
  return [ ListAddBack $(<) : $(>) ] ;
}

rule ListFilter LIST : INCLUDE : EXCLUDE {
  local t = [ Match "("$(2)")" : $(1) ] ;
  if $(3) {
    local r = ;
    for i in $(t) {
      # ECHO "I:" $(3) ":" $(i) ":" [ Match "("$(3)")" : $(i) ] ;
      if [ Match "("$(3)")" : $(i) ] = "" {
        r += $(i) ;
      }
    }
    return $(r) ;
  }
  else {
    return $(t) ;
  }
}

# ListStrAfterI LIST : AFTERTOKEN
rule ListStrAfterI {
  local r = ;
  for _s in $(<) {
    local s = [ StrAfterI $(_s) : "$(>)/" ] ;
    r += $(s) ;
  }
  return $(r) ;
}

# Gather files in a folder recursivly
# ListFiles DIR : PATTERN : EXCLUDE PATTERN
rule ListFilesR {
  local BD = [ FDirName $(1) ] ;
  local FD = [ ListDirsR $(BD) ] ;
  local F2 = [ ListFiles $(BD) $(FD) : $(2) : $(3) ] ;
  return $(F2) ;
}

# Returns the first element in the list
rule ListGetFirst {
  for _s in $(<) {
    return $(_s) ;
  }
}

#----------------------------------------------------------------------
#     File generation rules
#----------------------------------------------------------------------
actions EmptyFile {
  echo "" > "$(<)"
}

rule FileCat {
  #   ECHO "CAT: " $(>) " to " $(<) ;
  DEPENDS $(<) : $(>) ;
}
actions FileCat {
  cat "$(>)" >> "$(<)"
}
rule FileCatList {
  EmptyFile $(<) ;
  for _i in $(>) {
    FileCat $(<) : $(_i) ;
  }
}

rule FileEcho {
  NOTFILE $(>) ;
}
actions FileEcho {
  echo "$(>)" >> "$(<)"
}
rule FileEchoList {
  EmptyFile $(<) ;
  for _i in $(>) {
    FileEcho $(<) : $(_i) ;
  }
}

#----------------------------------------------------------------------
#     Bin2H rules
#----------------------------------------------------------------------

# Bin2H DEST : SRC : VARNAME ;
rule Bin2H {
  # ECHO "DEST:" $(<) ;
  # ECHO "SRC:" $(>) ;
  local var ;
  if $(3) {
    var = $(3) ;
  }
  else {
    var = [ Subst $(<:B) : %. : _ ] ;
  }
  # ECHO "VARNAME:" $(var) ;
  VARNAME on $(<) = $(var) ;
  DEPENDS $(<) : $(>) ;
  DEPENDS bin2h : $(<) ;
  return $(<) ;
}
actions Bin2H {
  bin2h $(>) $(<) $(VARNAME)
}

# DataSubDirBin2H TARGET : DIR : OBJDIR : EXTS
rule DataSubDirBin2H {
  local DATA = ;
  local EXTS = $(4) ;
  if ! $(EXTS) {
    EXTS = abm bmp dds jpg jpeg png tga xml wav flac ogg opus mp3 hdr psd avi ogv ogw mp4 ipcam webcam metal cgc cgh cgo xib nib ttf txt key yaml json html css js ;
  }
  local DATA_SRC = [ SrcSubDirGlobNoHdrs $(1) : $(2) : $(3) : $(EXTS) ] ;
  # ECHO "DATA_SRC:" $(DATA_SRC) ;
  for _s in $(DATA_SRC) {
    local d = [ FGristFiles [ FDirName $(SUBDIR) $(_s).hxx ] ] ;
    local dep = [ FGristFilesForDepends [ FDirName $(_s).hxx ] ] ;
    local s = [ FDirName $(SUBDIR) $(_s) ] ;
    # ECHO "s:" $(s) "->" $(d) "--->" $(dep) ;
    local r = [ Bin2H $(d) : $(s) ] ;
    # ECHO "r:" $(r) ;
    DEPENDS $(d) : $(s) ;
    DEPENDS $(dep) : $(d) ;
    DATA += $(d) ;
  }
  # ECHO "DATA:" $(DATA) ;
  DEPENDS $(<) : $(DATA) ;
  return $(DATA) ;
}

#----------------------------------------------------------------------
#     VarOn
#----------------------------------------------------------------------
# VarOnGet VARNAME ONWHAT
rule VarOnGet_ {
  return $($(<)) ;
}
rule VarOnGet {
  return [ on $(2) VarOnGet_ $(1) ] ;
}

# VarOnAddToFront VARNAME ONWHAT TOADD
rule VarOnAddToFront {
  # ECHO "# VAR: " $(1) ;
  # ECHO "# ON: " $(2) ;
  # ECHO "# TOADD: " $(3) ;
  $(1) on $(2) = $(3) [ VarOnGet $(1) : $(2) ] ;
}

#----------------------------------------------------------------------
#     Run
#----------------------------------------------------------------------
rule RunExe {
  DEPENDS $(<) : $(>) ;
  if ! $(3) {
    if $(SUBDIR) {
      WORKDIR on $(<) = $(SUBDIR) ;
    }
    else {
      WORKDIR on $(<) = . ;
    }
  }
  else {
    WORKDIR on $(<) = $(3) ;
  }
}
actions RunExe {
  cd $(WORKDIR)
  "./$(>)$(SUFEXE)" $(A0) $(A1) $(A2) $(A3) $(A4) $(A5) $(A6) $(A7) $(A8) $(A9)
}

#----------------------------------------------------------------------
#     Flymake
#----------------------------------------------------------------------
# FlyMakeSetup TARGET : CHK_SOURCES : (noremovetemp) ;
rule FlyMakeSetup
{
  if $(FLYMAKE_DONE) { return ; }

  if $(>) {
    NOTFILE $(<) ;
    local s = [ FGristFiles [ FTarget $(>) ] ] ;

    local ODIR = [ FDirName [ VarOnGet LOCATE_TARGET : $(>) ] $(>:D:G=) ] ;
    MkDir $(ODIR) ;

    Objects $(>) ;

    DEPENDS $(<) : $(ODIR) ;
    DEPENDS $(<) : $(s) ;
    if $(3) = noremovetemp {
      RmTemps $(<) : $(s) ;
    }
  }

  FLYMAKE_DONE = 1 ;
}

#----------------------------------------------------------------------
#     Standard directories and the cache file
#----------------------------------------------------------------------
TEMPDIR ?= [ FDirName $(HOME) _ham ] ;
BASEOBJDIR ?= [ FDirName $(TEMPDIR) obj ] ;
HCACHEFILE ?= [ FDirName $(TEMPDIR) _cache.ham ] ;

#----------------------------------------------------------------------
#     Include the toolset's base rules
#----------------------------------------------------------------------
Import base-$(HAM_CPP_TOOLSET)-rules.ham ;

#----------------------------------------------------------------------
#     Include the user's Hamfile
#----------------------------------------------------------------------
include $(JAMFILE) ;
