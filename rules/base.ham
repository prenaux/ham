# /+\
#  +\    Copyright 1993-2002 Christopher Seiwald and Perforce Software, Inc.
# \+/
#
# This file is part of Jam - see jam.c for Copyright information.
#

#
# 12/27/93 (seiwald) - purturb library sources with SOURCE_GRIST
# 04/18/94 (seiwald) - use '?=' when setting OS specific vars
# 04/21/94 (seiwald) - do RmTemps together
# 05/05/94 (seiwald) - all supported C compilers support -o: relegate
#              RELOCATE as an option; set Ranlib to "" to disable it
# 06/01/94 (seiwald) - new 'actions existing' to do existing sources
# 08/25/94 (seiwald) - new ObjectCcFlags rule to append to per-target CCFLAGS
# 08/29/94 (seiwald) - new ObjectHdrs rule to append to per-target HDRS
# 09/19/94 (seiwald) - LinkLibraries and Undefs now append
#            - Rule names downshifted.
# 10/06/94 (seiwald) - Dumb yyacc stuff moved into Jamfile.
# 10/14/94 (seiwald) - (Crude) support for .s, .C, .cc, .cpp, and .f files.
# 01/08/95 (seiwald) - Shell now handled with awk, not sed
# 01/10/95 (seiwald) - All entries sorted.
# 01/10/95 (seiwald) - NT support moved in, with LauraW's help.
# 01/10/95 (seiwald) - VMS support moved in.
# 02/06/95 (seiwald) - ObjectC++Flags and SubDirC++Flags added.
# 02/07/95 (seiwald) - Iron out when HDRSEARCH uses "" or SEARCH_SOURCE.
# 02/08/95 (seiwald) - SubDir works on VMS.
# 02/14/95 (seiwald) - MkDir and entourage.
# 04/30/95 (seiwald) - Use install -c flag so that it copies, not moves.
# 07/10/95 (taylor) - Support for Microsoft C++.
# 11/21/96 (peterk) - Support for BeOS
# 07/19/99 (sickel) - Support for Mac OS X Server (and maybe client)
# 02/18/00 (belmonte)- Support for Cygwin.

#
# Variables modifiers:
#
# :B -> Select filename base. This does not include the suffix.
# :S -> Select last filename suffix, if any; this includes the last dot (.)
# :D -> Select directory path
# :P -> Select "parent" directory path.
# :G -> Select the grist.
#
# :B=basename -> Replace each element's base name. Does not change the suffix.
# :S=suffix -> Replace each element's last suffix by suffix.
# :D=path -> Replace each element's directory path by path.
# :G=grist -> Replace each element's grist by path.
# :R=root -> Prepend root to each element, if it's not already rooted/absolute.
#
# :E -> Expand to the empty string if the variable is undefined, or normally otherwise.
# :E=value -> Expand to a given value if the variable is undefined, or normally otherwise.
# :J=separator -> Expands the variable into a single string, by concatenating its element with separator.
# :/ -- convert all \ to /
#	:\ -- convert all / to \
# :L -> Lowercase the variable.
# :U -> Uppercase the variable.
#

# Special targets defined in this file:
#
# all       - parent of first, shell, files, lib, exe
# first     - first dependent of 'all', for potential initialization
# shell     - parent of all Shell targets
# files     - parent of all File targets
# lib       - parent of all Library targets
# exe       - parent of all Main targets
# dirs      - parent of all MkDir targets
# clean     - removes all Shell, File, Library, and Main targets
#

# Rules defined by this file:
#
# as obj.o : source.s ;         .s -> .o
# Bulk dir : files ;            populate directory with many files
# Cc obj.o : source.c ;         .c -> .o
# C++ obj.o : source.cc ;       .cc -> .o
# Clean clean : sources ;       remove sources with 'jam clean'
# File dest : source ;          copy file
# GenFile source.c : program args ; make custom file
# HardLink target : source ;        make link from source to target
# HdrRule source : headers ;        handle #includes
# Library lib : source ;        archive library from compiled sources
# LibraryFromObjects lib : objects ;    archive library from objects
# LinkLibraries images : libraries ;    bag libraries onto Mains
# Main image : source ;         link executable from compiled sources
# MainFromObjects image : objects ; link executable from objects
# MkDir dir ;               make a directory, if not there
# Object object : source ;      compile object from source
# ObjectCcFlags source : flags ;    add compiler flags for object
# ObjectC++Flags source : flags ;   add compiler flags for object
# ObjectHdrs source : dirs ;        add include directories for object
# Objects sources ;         compile sources
# RmTemps target : sources ;        remove temp sources after target made
# Setuid images ;           mark executables Setuid
# SoftLink target : source ;        make symlink from source to target
# SubDir TOP d1 d2 ... ;        start a subdirectory Jamfile
# SubDirCcFlags flags ;         add compiler flags until next SubDir
# SubDirC++Flags flags ;        add compiler flags until next SubDir
# SubDirHdrs d1 d2 ... ;        add include dir until next SubDir
# SubInclude TOP d1 d2 ... ;        include a subdirectory Jamfile
# Shell exe : source ;          make a shell executable
# Undefines images : symbols ;      save undef's for linking
# UserObject object : source ;      handle unknown suffixes for Object
#
# Utility rules that have no side effects (not supported):
#
# FAppendSuffix f1 f2 ... : $(SUF) ;    return $(<) with suffixes
# FDirName d1 d2 ... ;          return path from root to dir
# FGrist d1 d2 ... ;            return d1!d2!...
# FGristFiles value ;           return $(value:G=$(SOURCE_GRIST))
# FGristSourceFiles value ;     return $(value:G=$(SOURCE_GRIST))
# FStripCommon v1 : v2 ;        strip common initial parts of v1 v2
# FReverse a1 a2 ... ;          return ... a2 a1
# FRelPath d1 : d2 ;            return rel path from d1 to d2
# FSubDir d1 d2 ... ;           return path to root
#

# Brief review of the jam language:
#
# Statements:
#   rule RULE - statements to process a rule
#   actions RULE - system commands to carry out target update
#
# Modifiers on actions:
#   together - multiple instances of same rule on target get executed
#          once with their sources ($(>)) concatenated
#   updated - refers to updated sources ($(>)) only
#   ignore - ignore return status of command
#   quietly - don't trace its execution unless verbose
#   piecemeal - iterate command each time with a small subset of $(>)
#   existing - refers to currently existing sources ($(>)) only
#   bind vars - subject to binding before expanding in actions
#
# Special rules:
#   Always - always build a target
#   Depends - builds the dependency graph
#   Echo - blurt out targets on stdout
#   Exit - blurt out targets and exit
#   Includes - marks sources as headers for target (a codependency)
#   NoCare - don't panic if the target can't be built
#   NoUpdate - create the target if needed but never update it
#   NotFile - ignore the timestamp of the target (it's not a file)
#   Temporary - target need not be present if sources haven't changed
#
# Special variables set by jam:
#   $(<) - targets of a rule (to the left of the :)
#   $(>) - sources of a rule (to the right of the :)
#   $(xxx) - true on xxx (UNIX, VMS, NT, OS2, MAC)
#   $(OS) - name of OS - varies wildly
#   $(JAMVERSION) - version number (3.0)
#
# Special variables used by jam:
#   SEARCH - where to find something (used during binding and actions)
#   LOCATE - where to plop something not found with SEARCH
#   HDRRULE - rule to call to handle include files
#   HDRSCAN - egrep regex to extract include files
#   HCACHEFILE - name of the header dependency cache
#   HCACHEMAXAGE - maximum age a cache entry can have before it is purged
#
# Special targets:
#   all - default if none given on command line
#


#========================================================================
# rule Split STRINGS : SPLIT_CHARACTERS
#========================================================================
#
# Splits each of the STRINGS at SPLIT_CHARACTERS. All splits are
# returned as a string list.
#
# Parameters:
#    STRINGS 	        The list of strings to split at the points specified by SPLIT_CHARACTERS.
#    SPLIT_CHARACTERS   One or more characters to split the list of
#                       STRINGS at. If the string starts with % the
#                       number afterward is converted to the following
#                       ascii character code.
#                       The Strings %t, %n and %r are converted to
#                       their matching ascii code.
#                       %nl Split at any new line character
#                       %s Space or tab character
#                       %w Split at any new line, space or tab character
#

#========================================================================
# rule Bash COMMANDS ;
#========================================================================
#
# The Bash rule is used to execute one or more COMMANDS and return
# the output to the user. Each command specified in the COMMANDS list
# is executed immediately, one after another. The results of a command
# execution are returned to the caller.
#
# Parameters:
#   COMMANDS 	A list of one or more commands, each executed serially.
#
#>> # Copy file1.txt to file2.txt, ignoring output.
#>> Bash "cp file1.txt file2.txt" ;
#>>
#>> # Grab a directory listing.
#>> dir_listing = [ Bash ls ] ;
#>>
#>> # Grab two directory listings.
#>> dir_listings = [ Bash "ls *.tga" "ls *.png" ]
#>> Echo dir *.tga - $(dir_listings[1]) ;
#>> Echo dir *.png - $(dir_listings[2]) ;
#

#========================================================================
# rule Match REGEXPS : LIST ;
#========================================================================
# Matches the egrep(1) style regular expressions REGEXPS against the
# strings in LIST. The result is the concatenation of matching ()
# subexpressions for each string in LIST, and for each regular
# expression in REGEXPS. Only useful within the [ ] construct, to
# change the result into a list.

#========================================================================
# rule Math LEFT OPERATOR RIGHT ;
#========================================================================
# Calculates the result of the simple math equation of the form LEFT
# OPERATOR RIGHT. Useful only within the [ ] construct, to change the
# result into a list.
# - Parameters:
#     LEFT  	An integer for the left side of the equation.
#     OPERATOR 	+ for addition, - for subtraction, * for multiplication, / for division, and % for modulus.
#     RIGHT 	An integer for the right side of the equation.
# - Returns:
#     Returns the result of the equation.

#========================================================================
# rule Subst LIST : PATTERN [ : REPL [ : MAXN ] ] ;
#========================================================================
# Note: The Subst rule comes from the Lua code base's implementation
#       of string.gsub. The documentation below is near verbatim from
#       the Lua manual.
#
# Returns a copy of LIST in which all occurrences of the PATTERN have
# been replaced by a replacement string specified by REPL. Only useful
# within the [ ] construct, to change the result into a list.
#
# The character % works as an escape character: any sequence in repl
# of the form n, with n between 1 and 9, stands for the value of the
# n-th captured substring (see below). The sequence 0 stands for the
# whole match. The sequence %% stands for a single %.
#
# The optional last parameter n limits the maximum number of
# substitutions to occur. For instance, when n is 1 only the first
# occurrence of pattern is replaced.
#
# Parameters:
#
#    	LIST: The list of strings to apply the regular expression
#    	       substitution algorithm to.
#
#    	PATTERN: The regular expression pattern to search for within
#    	         LIST. If the pattern is found, it is replaced with REPL.
#
#    	REPL: (optional) If specified, any patterns matched with
#    	      PATTERN are replaced with the contents of REPL. If not
#    	      specified, the replacement string is empty.
#
#    	MAXN: (optional) The maximum number of substitutions to occur.
#
#>> # __/__/dir/__/dir2
#>> Echo [ Subst ../../dir/../dir2 : %.%. : __ ] ;
#>>
#>> # hello hello world world
#>> Echo [ Subst "hello world" : "(%w+)" : "%1 %1" ] ;
#>>
#>> # hello hello world
#>> Echo [ Subst "hello world" : "%w+" : "%0 %0" : 1 ] ;
#>>
#>> # world hello Lua from
#>> Echo [ Subst "hello world from Lua" : "(%w+)%s*(%w+)" : "%2 %1" ] ;
#
# Patterns
# Character Class:
#
# A character class is used to represent a set of characters. The
# following combinations are allowed in describing a character class:
#
#    x: (where x is not one of the magic characters ^$()%.[]*+-?) represents the character x itself.
#
#    .: (a dot) represents all characters.
#
#    a: represents all letters.
#
#    c: represents all control characters.
#
#    d: represents all digits.
#
#    l: represents all lowercase letters.
#
#    p: represents all punctuation characters.
#
#    s: represents all space characters.
#
#    u: represents all uppercase letters.
#
#    w: represents all alphanumeric characters.
#
#    x: represents all hexadecimal digits.
#
#    z: represents the character with representation 0.
#
#    %x: (where x is any non-alphanumeric character) represents the
#        %character x. This is the standard way to escape the magic
#        %characters. Any punctuation character (even the non magic)
#        %can be preceded by a '%' when used to represent itself in a
#        %pattern.
#
#    [set]: represents the class which is the union of all characters
#           in set. A range of characters may be specified by
#           separating the end characters of the range with a '-'. All
#           classes %x described above may also be used as components
#           in set. All other characters in set represent
#           themselves. For example, [w_] (or [_w]) represents all
#           alphanumeric characters plus the underscore,
#
#    [0-7] represents the octal digits, and [0-7l-] represents the
#          octal digits plus the lowercase letters plus the '-'
#          character.
#
#    The interaction between ranges and classes is not
#    defined. Therefore, patterns like [a-z] or [a-%%] have no
#    meaning.
#
#    [^set]: represents the complement of set, where set is interpreted as above.
#
# For all classes represented by single letters (a, c, etc.), the
# corresponding uppercase letter represents the complement of the
# class. For instance, S represents all non-space characters.
#
# The definitions of letter, space, and other character groups depend
# on the current locale. In particular, the class [a-z] may not be
# equivalent to l.
#
# Pattern Item: A pattern item may be
#
#     a single character class, which matches any single character in the class;
#
#     a single character class followed by '*', which matches 0 or
#     more repetitions of characters in the class. These repetition
#     items will always match the longest possible sequence;
#
#     a single character class followed by '+', which matches 1 or
#     more repetitions of characters in the class. These repetition
#     items will always match the longest possible sequence;
#
#     a single character class followed by '-', which also matches 0
#     or more repetitions of characters in the class. Unlike '*',
#     these repetition items will always match the shortest possible
#     sequence;
#
#     a single character class followed by '?', which matches 0 or 1
#     occurrence of a character in the class;
#
#     %n, for n between 1 and 9; such item matches a substring equal
#     %to the n-th captured string (see below);
#
#     bxy, where x and y are two distinct characters; such item
#     matches strings that start with x, end with y, and where the x
#     and y are balanced. This means that, if one reads the string
#     from left to right, counting +1 for an x and -1 for a y, the
#     ending y is the first y where the count reaches 0. For instance,
#     the item b() matches expressions with balanced parentheses.
#
# Pattern:
#
#     A pattern is a sequence of pattern items. A '^' at the beginning
#     of a pattern anchors the match at the beginning of the subject
#     string. A '$' at the end of a pattern anchors the match at the
#     end of the subject string. At other positions, '^' and '$' have
#     no special meaning and represent themselves.  Captures:
#
#     A pattern may contain sub-patterns enclosed in parentheses; they
#     describe captures. When a match succeeds, the substrings of the
#     subject string that match captures are stored (captured) for
#     future use. Captures are numbered according to their left
#     parentheses. For instance, in the pattern "(a*(.)%w(%s*))", the
#     part of the string matching "a*(.)%w(%s*)" is stored as the
#     first capture (and therefore has number 1); the character
#     matching "<code>.</code>" is captured with number 2, and the
#     part matching "<code>%s*</code>" has number 3.
#
#     As a special case, the empty capture () captures the current
#     string position (a number). For instance, if we apply the
#     pattern "()aa()" on the string "flaaap", there will be two
#     captures: 3 and 5.
#
#     A pattern cannot contain embedded zeros. Use z instead.
#

#----------------------------------------------------------------------
#     OS Specific
#----------------------------------------------------------------------

# the OS envvar is declared by Xcode in OSX, so we override it here
if $(OS) = MACOS {
  OS = MACOSX ;
}

#----------------------------------------------------------------------
#     Basic variables
#----------------------------------------------------------------------
# Logging level
# 0 - Debug
# 1 - Verbose
# 2 - Info
# 3 - Warnings
# 4 - Errors
LOG ?= 2 ;

LINT ?= 0 ;

if $(FLYMAKE) = 1 {
  FLYMAKE_PCH ?= 0 ;
  ECHO "I/Flymake build" ;
}

if $(LINT_C) && $(LINT_H) {
  # CAN_LINT = 1 ;
  CAN_LINT = 0 ; # Lint breaks Flymake for Android build...
}
if ( $(FLYMAKE) = 1 ) && ( $(CAN_LINT) = 1 ) {
  LINT_OBJECTS = 1 ;
}

#----------------------------------------------------------------------
#     Import rules
#----------------------------------------------------------------------
rule ImportBuildPath {
  if [ FExists $(<) ] {
    return $(<) ;
  }

  PATH = $(HAM_HOME)/rules/$(<) ;
  if ! [ FExists $(PATH) ] {
    if $(>) {
      EXIT $(>) ;
    }
    else {
      EXIT "E/Can't find import:" $(PATH) ;
    }
  }

  return $(PATH) ;
}

rule ImportIsImported {
  if ! $(IMPORTED_$(<)) {
    return ;
  }
  return 1 ;
}

rule ImportMarkImported {
  IMPORTED_$(<) = 1 ;
}

rule Import {
  PATH = [ ImportBuildPath $(<) ] ;
  if [ ImportIsImported $(PATH) ] {
    if $(LOG) <= 0 {
      ECHO "D/ Already imported: " $(PATH) ;
    }
  }
  else {
    if $(LOG) <= 0 {
      ECHO "D/ Importing:" $(PATH) ;
    }
    ImportMarkImported $(PATH) ;
    include $(PATH) ;
  }
}

#----------------------------------------------------------------------
#     Pre-requisit utilities
#----------------------------------------------------------------------
rule FDirName
{
  # Turn individual elements in $(<) into a usable path.

  local _i ;
  local _s = $(DOT) ;
  # So that FDirName works when used in the base-*.ham files which doesnt have
  # the default definition of $(DOT) yet.
  if ! $(_s) {
    _s = . ;
  }

  for _i in $(<)
  {
    _s = $(_i:R=$(_s)) ;
  }

  return $(_s) ;
}

rule FGristDirName
{
  return [ FGristFiles [ FDirName $(<) ] ] ;
}

rule FQuote {
  if $(<) {
    return "\"$(<)\"" ;
  }
  else {
    return "\"\"" ;
  }
}

rule FQuoteFlag {
  if $(>) {
    return $(<)"\"$(>)\"" ;
  }
  else {
    return "\"\"" ;
  }
}

rule FQuoteDirName {
  return [ FQuote [ FDirName $(<) ] ] ;
}

#----------------------------------------------------------------------
#     Toolset
#----------------------------------------------------------------------
if ! $(HAM_TOOLSET) {
  EXIT "F/HAM_TOOLSET not set." ;
}
Import base-$(HAM_TOOLSET).ham ;

#----------------------------------------------------------------------
#     General defaults; a lot like UNIX
#----------------------------------------------------------------------
PREFIXDLL ?= "" ;
DLLIMPLIB ?= ;
SUFDLLOBJ ?= $(SUFOBJ) ;
SUFDLL    ?= $(SUFLIB) ;

AR      ?= ar ru ;
AS      ?= as ;
ASFLAGS     ?= ;
YASM    ?= nasm ;
YASMFLAGS    ?= ;
AWK     ?= awk ;
BINDIR      ?= /usr/local/bin ;
C++     ?= cc ;
C++FLAGS    ?= ;
CC      ?= cc ;
CCFLAGS     ?= ;
CP      ?= cp -f ;
CP_PRESERVE ?= $(CP) -p ;
CRELIB      ?= ;
DOT     ?= . ;
DOTDOT      ?= .. ;
EXEMODE     ?= 711 ;
FILEMODE    ?= 644 ;
ROMODE      ?= 444 ;
HDRS        ?= ;
INSTALLGRIST    ?= installed ;
JAMFILE     ?= _build.ham ;
JAMRULES    ?= _rules.ham ;
LIBDIR      ?= /usr/local/lib ;
LINK        ?= $(CC) ;
LINKFLAGS   ?= ;
LINKLIBS    ?= ;
SYSTEM_LINKLIBS ?= ;
LN      ?= ln ;
MANDIR      ?= /usr/local/man ;
MKDIR       ?= mkdir -p ;
MV      ?= mv -f ;
OPTIM       ?= ;
RCP     ?= rcp ;
RM      ?= rm -f ;
RMDIR       ?= $(RM) ;
RSH     ?= rsh ;
SED     ?= sed ;
SHELLHEADER ?= "#!/bin/sh" ;
SHELLMODE   ?= 755 ;
SLASH       ?= / ;
QUOTE       ?= "\"" ;
SUBDIRRULES     ?= ;
SUBDIRRESET     ?= ASFLAGS YASMFLAGS HDRS C++FLAGS CCFLAGS ;
SUFEXE      ?= "" ;
SUFLIB      ?= .a ;
SUFOBJ      ?= .o ;
UNDEFFLAG   ?= "-u _" ;
RCFLAGS     ?= ;
SUFJAVAC    ?= .class ;

HDRPATTERN =
"^[ 	]*#[ 	]*include[ 	]*[<\"]([^\">]*)[\">].*$" ;

OSFULL = $(OS)$(OSVER)$(OSPLAT) $(OS)$(OSPLAT) $(OS)$(OSVER) $(OS) ;

TARGET_OS ?= $(OS) ;

#
# Base dependencies - first for "bootstrap" kinds of rules
#

Depends all : shell files lib exe obj beam ;
Depends all shell files lib exe obj beam : first ;
NotFile all first shell files lib exe obj beam dirs clean uninstall ;
Always  clean uninstall ;

#
# Rules
#

# /As object : source ;
#
# Assemble (.s) the file _source_, called by the @Object rule.
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule As
{
  Depends $(<) : $(>) ;
  ASFLAGS on $(<) += $(ASFLAGS) $(SUBDIRASFLAGS) ;
  ASHDRS on $(<) = [ FIncludes $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ] ;
}

# /Yasm object : source ;
#
# Assemble (.asm) the file _source_, called by the @Object rule.
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule Yasm
{
  Depends $(<) : $(>) ;
  YASMFLAGS on $(<) += $(YASMFLAGS) $(SUBDIRYASMFLAGS) ;
  YASMHDRS on $(<) = [ FIncludesDash $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ] ;
  YASMDEFS on $(<) = [ on $(<) FDefinesDash $(DEFINES) ] ;
}

rule Masm
{
  Depends $(<) : $(>) ;
}

# /Bulk  directory : sources ;
#
# Copies _sources_ into _directory_
#
rule Bulk
{
  local i ;

  for i in $(>)
  {
    File $(i:D=$(<)) : $(i) ;
  }
}

# /Cc object : source ;
#
# Compile the file source into object, using the C compiler $(CC), its
# flags $(CCFLAGS) and $(OPTIM), and the header file directories $(HDRS).
# Called by the @Object rule
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule Cc
{
  Depends $(<) : $(>) ;

  # If the compiler's -o flag doesn't work, relocate the .o

  if $(RELOCATE)
  {
    CcMv $(<) : $(>) ;
  }

  # Just to clarify here: this sets the per-target CCFLAGS to
  # be the current value of (global) CCFLAGS and SUBDIRCCFLAGS.
  # CCHDRS and CCDEFS must be reformatted each time for some
  # compiles (VMS, NT) that malign multiple -D or -I flags.

  CCFLAGS on $(<) += $(CCFLAGS) $(SUBDIRCCFLAGS) ;

  CCHDRS on $(<) = [ on $(<) FIncludes $(HDRS) ] ;
  CCDEFS on $(<) = [ on $(<) FDefines $(DEFINES) ] ;
}

# /C99 object : source ;
#
# Compile the C99 source file _source_. Similar to @CC, called by @Object
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule C99
{
  Depends $(<) : $(>) ;

  if $(RELOCATE) {
    CcMv $(<) : $(>) ;
  }

  CCFLAGS on $(<) += $(CCFLAGS) $(SUBDIRCCFLAGS) ;
  C99FLAGS on $(<) += $(C99FLAGS) $(SUBDIRC99FLAGS) ;

  CCHDRS on $(<) = [ on $(<) FIncludes $(HDRS) ] ;
  CCDEFS on $(<) = [ on $(<) FDefines $(DEFINES) ] ;
}

# /C++ object : source ;
#
# Compile the C++ source file _source_. Similar to @CC, called by @Object
#
# Do not call this rule directly, since _object_ and _source_ may have
# have platform-specific file extensions
#
rule C++
{
  Depends $(<) : $(>) ;

  if $(RELOCATE)
  {
    CcMv $(<) : $(>) ;
  }

  C++FLAGS on $(<) += $(C++FLAGS) $(SUBDIRC++FLAGS) ;

  CCHDRS on $(<) = [ on $(<) FIncludes $(HDRS) ] ;
  CCDEFS on $(<) = [ on $(<) FDefines $(DEFINES) ] ;
}

# /Chmod target ;
#
# (Unix and VMS only). Change file permissions on _target_ to target-specific
# $(MODE) value set by @Link, @File, and @Shell rules
#
rule Chmod
{
  if $(CHMOD) { Chmod1 $(<) ; }
}

# /Clean  clean : targets ;
#
# Removes existing _targets_ when _clean_ is built. clean is not a dependency
# of all, and must be built explicitely for targets to be removed
#

# /File target : source ;
#
# Copies _source_ into _target_
#
rule File
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  MODE on $(<) = $(FILEMODE) ;
  Chmod $(<) ;
}

# Same as file, but preserve time and attributes of the file
rule FilePreserve
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  MODE on $(<) = $(FILEMODE) ;
  Chmod $(<) ;
}

rule FilePreserveRO
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  MODE on $(<) = $(ROMODE) ;
  Chmod $(<) ;
}

if $(OS) = MACOSX {
  actions FilePreserveRO
  {
    # unlock the destination if its locked, this can happen if using other file system than HFS on OSX
    chflags -f nouchg "$(<)"
    ham-exec-retry $(CP_PRESERVE) "$(>)" "$(<)"
  }
}
else {
  actions FilePreserveRO
  {
    ham-exec-retry $(CP_PRESERVE) "$(>)" "$(<)"
  }
}

rule FilePreserveEXE
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  MODE on $(<) = $(EXEMODE) ;
  Chmod $(<) ;
}
actions FilePreserveEXE
{
  ham-exec-retry $(CP_PRESERVE) "$(>)" "$(<)"
}

# Straight copy
rule Cp
{
  Depends $(<) : $(>) ;
}

# /GenFile target : image sources ;
#
# Runs the command "_image_ _target_ _sources_" to create _target_ from
# _sources_ and _image_ (where _image_ is an executable built by the
# @Main rule)
#
rule GenFile
{
  local _t = [ FGristSourceFiles $(<) ] ;
  local _s = [ FAppendSuffix $(>[1]) : $(SUFEXE) ] ;
  Depends $(_t) : $(_s) $(>[2-]) ;
  GenFile1 $(_t) : $(_s) $(>[2-]) ;
  Clean clean : $(_t) ;
}

rule GenFile1
{
  MakeLocate $(<) : $(LOCATE_SOURCE) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

# /HardLink target : source ;
#
# Makes _target_ a hard link to _source_, if it isn't one already
# (Unix only)
#
rule HardLink
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
}

# /HdrMacroFile
#
# this rule is specific to FT-Jam. It is used to indicate that a given file
# contains definitions for filename macros (e.g. "#define MYFILE_H <myfile>.h")
# that can later be used in #include statements in the rest of the source
#
# these files must be parsed before any make is tried.
#
rule HdrMacroFile
{
  HDRMACRO $(<) ;
}

# /HdrRule source : headers ;
#
# Arranges the proper dependencies when the file _source_ includes the files
# _headers_ through the #include C preprocessor directive
#
# this rule is not intendend to be called explicitely. It is called
# automatically during header scanning on sources handled by the @Object
# rule (e.g. sources in @Main or @Library rules)
#
rule HdrRule
{
  # HdrRule source : headers ;

  # N.B.  This rule is called during binding, potentially after
  # the fate of many targets has been determined, and must be
  # used with caution: don't add dependencies to unrelated
  # targets, and don't set variables on $(<).

  # Tell Jam that anything depending on $(<) also depends on $(>),
  # set SEARCH so Jam can find the headers, but then say we don't
  # care if we can't actually find the headers (they may have been
  # within ifdefs),

  local s = $(>:G=$(HDRGRIST:E)) ;
  local t = $(HDRSEARCH) ;
  t += $(DEPHDRS) ;

  #  Echo "MYHDR: " $(t) ;

  Includes $(<) : $(s) ;
  SEARCH on $(s) = $(HDRSEARCH) ;
  NoCare $(s) ;

  # Propagate on $(<) to $(>)

  #   local t = $(HDRSEARCH) ;
  #   Echo "MYHDR([$(<:D)]-[$(>:D)]): " $(HDRSEARCH) ;
  #   for _i in $(HDRSEARCH) {
    # 	t += [ FDirName $(_i) $(<:D) ] ;
    # 	t += [ FDirName $(_i) $(>:D) ] ;
  #   }
  t += $(HDROPENED:DC) ;
  #  Echo "HDROPEN: " $(HDROPENED:D) ;

  HDRSEARCH on $(s) = $(t) ;
  HDRSCAN on $(s) = $(HDRSCAN) ;
  HDRRULE on $(s) = $(HDRRULE) ;
  HDRGRIST on $(s) = $(HDRGRIST) ;
}

# /Library  library : sources : objs ;
#
#  Compiles _sources_ and archives them into _library_. The intermediate
#  objects are deleted. Calles @Object and @LibraryFromObjects
#
#  If @Library is invoked with no suffix on _library_, the $(SUFLIB)
#  suffix is used
#
rule Library
{
  LibraryFromObjects $(<) : $(>:S=$(SUFOBJ)) $(3) ;
  Objects $(>) ;
}

# /SharedLibrary  library : sources : def : import : objs ;
#
# Compiles _sources_ and generates a shared _library_ (i.e. DLL on Windows,
# or shared object on Unix). Calls @SharedObjects and @SharedLibraryFromObjects
#
# If @SharedLibrary is invoked with no suffix on _library_, then
# $(SUFDLL) suffix is used
#
# _def_ is the name of the corresponding definition file used to generate
# the library on Windows and OS/2 (ignored otherwise). If undefined, it
# will default to _library_ with the .def suffix
#
# _import_ is the name of the corresponding import library for Windows
# and OS/2 platforms (ignored otherwise). If undefined, it will default
# to _library_ with the .dll.lib suffix.
#
rule SharedLibrary
{
  SharedLibraryFromObjects $(<) : $(>:S=$(SUFDLLOBJ)) $(5) : $(3) : $(4) ;
  SharedObjects            $(>) ;
}

# Same as SharedLibrary, but also output a static library along side the dll
rule SharedAndStaticLibrary
{
  SharedLibraryFromObjects $(<) : $(>:S=$(SUFDLLOBJ)) $(5) : $(3) : $(4) ;
  LibraryFromObjects $(<) : $(>:S=$(SUFOBJ)) $(5) ;
  SharedObjects $(>) ;
}

# /LibraryFromObjects library : objects ;
#
# Archives _objects_ into _library_. The _objects_ are then deleted
#
# If _library_ has no suffix, the $(SUFLIB) suffix is used
#
# Called by @Library rule. Most people should never call this rule
# directly.
#
rule LibraryFromObjects
{
  local _i _l _s ;

  # Add grist to file names

  _s = [ FGristFiles $(>) ] ;
  _l = $(<:S=$(SUFLIB)) ;

  # library depends on its member objects

  if $(DELOBJS)
  {
    Depends lib : $(_l) ;
  }
  else
  {
    Depends obj : $(_s) ;
  }

  # Set LOCATE for the library and its contents.  The bound
  # value shows up as $(NEEDLIBS) on the Link actions.
  # For compatibility, we only do this if the library doesn't
  # already have a path.

  if ! $(_l:D)
  {
    MakeLocate $(_l) $(_l)($(_s:BS)) : $(LOCATE_TARGET) ;
  }

  if ( ! $(DELOBJS) ) ||  $(NOARSCAN)
  {
    # If we can't scan the library to timestamp its contents,
    # we have to just make the library depend directly on the
    # on-disk object files.

    Depends $(_l) : $(_s) ;
  }
  else
  {
    # If we can scan the library, we make the library depend
    # on its members and each member depend on the on-disk
    # object file.

    Depends $(_l) : $(_l)($(_s:BS)) ;

    for _i in $(_s)
    {
      Depends $(_l)($(_i:BS)) : $(_i) ;
    }
  }

  Clean clean : $(_l) ;

  if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }

  Archive $(_l) : $(_s) ;

  if $(RANLIB) { Ranlib $(_l) ; }

  # If we can't scan the library, we have to leave the .o's around.

  if $(DELOBJS) && ! ( $(NOARSCAN) || $(NOARUPDATE) ) { RmTemps $(_l) : $(_s) ; }
}


# /SharedLibraryFromObjects  library : objects : def : import ;
#
# Equivalent of @LibraryFromObjects for shared libraries.
#
# Called by @SharedLibrary. Most people shouldn't call this rule
# directly
#
rule SharedLibraryFromObjects
{
  local _i _l _s ;

  # Add grist to file names

  _s = [ FGristFiles $(>) ] ;
  _l = $(<:S=$(SUFDLL)) ;

  #Echo "Library is $(_l)"    ;
  # library depends on its member objects

  if $(DELOBJS)
  {
    Depends lib : $(_l) ;
  }
  else
  {
    Depends obj : $(_s) ;
  }

  # Set LOCATE for the library and its contents.  The bound
  # value shows up as $(NEEDLIBS) on the Link actions.
  # For compatibility, we only do this if the library doesn't
  # already have a path.

  if ! $(_l:D)
  {
    MakeLocate $(_l) : $(LOCATE_TARGET) ;
  }

  # we never scan shared libraries for member objects
  Depends $(_l) : $(_s) ;

  Clean clean : $(_l) ;

  # I don't know if VMS supports shared libraries, so I prefer
  # to disable the following right now
  #
  #if $(CRELIB) { CreLib $(_l) : $(_s[1]) ; }

  if $(OS) = LINUX || $(OS) = MACOSX
  {
    DllLink $(_l) : $(_s) ;
  }
  else if $(NT)
  {
    local  _implib = $(4) ;

    _implib ?= $(_l:S=$(SUFLIB)) ;

    Clean    clean : $(_implib) ;
    Depends  lib   : $(_implib) ;

    Depends $(_implib) : $(_l) ;
    Depends $(_l)      ;

    IMPLIBNAME  on $(_l) = $(_implib) ;

    MakeLocate $(_implib)        : $(LOCATE_TARGET) ;
    MakeLocate $(_implib:S=.exp) : $(LOCATE_TARGET) ;

    SharedLink $(_l) : $(_s) : $(_implib) ;

    DllLink $(_l) : $(_s) ;
  }
  else
  {
    Echo "Sorry, I don't know how to make a shared library on your system" ;
    Exit "Please contact the Ham maintainer for help" ;
  }
}

# /Link  image : objects ;
#
# Links _image_ from _objects_ and sets permissions on _image_ to
# $(EXEMODE). _image_ must be an actual filename; suffix is not
# supplied.
#
# Called by @Main, shouldn't be called by most people
#
rule Link
{
  MODE on $(<) = $(EXEMODE) ;
  Chmod $(<) ;
}

# /LinkLibraries image : libraries ;
#
# Makes _image_ depend on _libraries_ and includes them during linking
#
# _image_ may be referenced without a suffix in this rule invocation.
# @LinkLibraries supplies the suffix
#
# You should only use this rule with libraries created through the
# @Library rule. For external libraries, use something else (XXX)
#
rule LinkLibraries
{
  # make library dependencies of target
  # set NEEDLIBS variable used by 'actions Main'

  local _t = [ FAppendSuffix $(<) : $(SUFEXE) ] ;

  Depends $(_t) : $(>:S=$(SUFLIB)) ;
  NEEDLIBS on $(_t) += $(>:S=$(SUFLIB)) ;
}

# /LinkSharedLibraries image : libraries :
#
# Same as @LinkLibraries, but to link _image_ with shared libraries
# generated through the @SharedLibrary rule
#
rule LinkSharedLibraries
{
  # make library dependencies of target
  # set NEEDLIBS variable used by 'actions Main'

  local _t   = [ FAppendSuffix $(<) : $(SUFEXE) ] ;
  local _ext = $(SUFDLL) ;

  if $(NT) || $(OS2)
  {
    # on NT or OS/2, we need to link agains the import library,
    # not the DLL itself !!
    #
    _ext = $(SUFDLL)$(SUFLIB) ;
  }
  Depends $(_t) : $(>:S=$(_ext))  ;
  NEEDLIBS on $(_t) += $(>:S=$(_ext)) ;
}

# /Main image : sources : objs ;
#
# Compiles _sources_ and links them into _image_. Calls @Objects and
# @MainFromObjects.
#
# _image_ may be supplied without suffix.
#
rule Main
{
  MainFromObjects $(<) : $(>:S=$(SUFOBJ)) $(3) ;
  Objects $(>) ;
}

# /MainFromObjects image : objects ;
#
# Links _objects_ into _image_. Dependency of exe.
# @MainFromObjects provides a default suffix for _image_
#
rule MainFromObjects
{
  local _s _t ;

  # Add grist to file names
  # Add suffix to exe

  _s = [ FGristFiles $(>) ] ;
  _t = [ FAppendSuffix $(<) : $(SUFEXE) ] ;

  # so 'jam foo' works when it's really foo.exe

  if $(_t) != $(<)
  {
    Depends $(<) : $(_t) ;
    NotFile $(<) ;
  }

  # make compiled sources a dependency of target

  Depends exe : $(_t) ;
  Depends $(_t) : $(_s) ;
  MakeLocate $(_t) : $(LOCATE_TARGET) ;

  Clean clean : $(_t) ;

  # special case for stupid Borland C++, which always generates a
  # .tds file for executables, even when no debug information is needed
  #
  if $(HAM_TOOLSET) = BORLANDC {
    MakeLocate $(_t:S=.tds) : $(LOCATE_TARGET) ;
    Clean  clean : $(_t:S=.tds) ;
  }

  Link $(_t) : $(_s) ;
}

# /MakeLocate  targets : directory
#
# Creates _dir_ and causes _target_ to be built into _dir_
#
# This is done by setting the target-specific variable LOCATE
# on _targets_, and arranges with @MkDir to create the target
# directory
#
rule MakeLocate
{
  # Note we grist the directory name with 'dir',
  # so that directory path components and other
  # targets don't conflict.

  if $(>)
  {
    LOCATE on $(<) = $(>) ;
    Depends $(<) : $(>[1]:G=dir) ;
    MkDir $(>[1]:G=dir) ;
  }
}

# MakeDirForTarget TARGET : DIR
rule MakeDirForTarget
{
  # Note we grist the directory name with 'dir',
  # so that directory path components and other
  # targets don't conflict.

  if $(>)
  {
    Depends $(<) : $(>[1]:G=dir) ;
    MkDir $(>[1]:G=dir) ;
  }
}

# /MkDir  dir ;
#
# Creates _dir_ and its parent directories
#
rule MkDir
{
  # Ignore timestamps on directories: we only care if they
  # exist.

  NoUpdate $(<) ;

  # Don't create . or any directory already created.

  if $(<:G=) != $(DOT) && ! $($(<)-mkdir)
  {
    # Cheesy gate to prevent multiple invocations on same dir
    # Arrange for jam dirs
    # MkDir1 has the actions

    $(<)-mkdir = true ;
    Depends dirs : $(<) ;
    MkDir1 $(<) ;

    # Recursively make parent directories.
    # $(<:P) = $(<)'s parent, & we recurse until root

    local s = $(<:P) ;

    # Don't try to create A: or A:\ on windows

    if $(NT)
    {
      switch $(s)
      {
        case *:   : s = ;
        case *:\\ : s = ;
      }
    }

    # handle "C:", "C:/", "/cygdrive" and "/cygdrive/" in Cygwin
    if $(UNIX) && $(OS) = CYGWIN
    {
      switch $(s)
      {
        case ?:   : s = ;
        case ?:/  : s = ;
        case <dir>/cygdrive   : s = ;
        case <dir>/cygdrive/  : s = ;
      }
    }

    if $(s) = $(<)
    {
      # The parent is the same as the dir.
      # We're at the root, which some OS's can't stat, so we mark
      # it as NotFile.

      NotFile $(s) ;
    }
    else if $(s:G=)
    {
      # There's a parent; recurse.

      Depends $(<) : $(s) ;
      MkDir $(s) ;
    }
  }
}

# /Object object : source ;
#
# Compile s a single _source_ file into _object_. The @Main and @Library
# rules use it to compile sources.
#
# Causes _source_ to be scanned for #include directives and calls @HdrRule
# to make all included files dependencies of _object_.
#
# Calls one of the following rules depending on the suffix to do the
# actual compilation:
#
rule Object
{
  # locate object and search for source, if wanted
  Clean clean : $(<) ;

  MakeLocate $(<) : $(LOCATE_TARGET) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;

  # Save HDRS for -I$(HDRS) on compile.
  # We shouldn't need -I$(SEARCH_SOURCE) as cc can find headers
  # in the .c file's directory, but generated .c files (from
  # yacc, lex, etc) are located in $(LOCATE_TARGET), possibly
  # different from $(SEARCH_SOURCE).

  HDRS on $(<) = $(SEARCH_SOURCE) $(SUBDIRHDRS) $(HDRS) ;

  # handle #includes for source: Jam scans for headers with
  # the regexp pattern $(HDRSCAN) and then invokes $(HDRRULE)
  # with the scanned file as the target and the found headers
  # as the sources.  HDRSEARCH is the value of SEARCH used for
  # the found header files.  Finally, if jam must deal with
  # header files of the same name in different directories,
  # they can be distinguished with HDRGRIST.

  # $(SEARCH_SOURCE:E) is where cc first looks for #include
  # "foo.h" files.  If the source file is in a distant directory,
  # look there.  Else, look in "" (the current directory).

  HDRRULE on $(>) = HdrRule ;
  HDRSCAN on $(>) = $(HDRPATTERN) ;
  HDRSEARCH on $(>) =
  $(SEARCH_SOURCE:E) $(SUBDIRHDRS) $(HDRS) $(STDHDRS) ;

  HDRGRIST on $(>) = $(HDRGRIST) ;

  # propagate target specific-defines

  DEFINES on $(<) += $(DEFINES) ;

  local COMPILER = [ VarOnGet COMPILER : $(<) ] ;
  if $(COMPILER) {
    # ECHO "I/CUSTOM COMPILER FOR:" $(<) ":" $(COMPILER) ;
    $(COMPILER) $(<) : $(>) ;
  }
  else {
    local COMPILE_AS = [ VarOnGet COMPILE_AS : $(>) ] ;
    if ! $(COMPILE_AS) {
      COMPILE_AS = $(>:S) ;
    }

    # ECHO "COMPILE_AS:" $(>) "::" $(COMPILE_AS) ;

    # if source is not .c, generate .c with specific rule
    switch $(COMPILE_AS)
    {
      case .h   : if $(CAN_LINT) { LintH lint_h : $(>) ; }
      case .hpp : if $(CAN_LINT) { LintH lint_h : $(>) ; }
      case .asm : Yasm $(<) : $(>) ;
      case .masm : Masm $(<) : $(>) ;
      case .c :   Cc $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .m :   Cc $(<) : $(>) ;
      case .c99 : C99 $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .C :   C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .cc :  C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .cpp : C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .cxx : C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .c++ : C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .C++ : C++ $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case .mm  : C++ $(<) : $(>) ;
      case .s :
        As $(<) : $(>) ;
      case .rc :  ResourceCompiler $(<) : $(>) ;
      case .cni : Cni $(<) : $(>) ; if $(CAN_LINT) { LintC lint_c : $(>) ; }
      case * :    UserObject $(<) : $(>) ;
    }
  }
}

# /CompileAs sources : ext ;
#
# Compile the specified source files as if it was of the specified extension.
#
rule CompileAs
{
  COMPILE_AS on [ FGristFiles $(<) ] = $(>) ;
}

# nicc compiler
rule Cni
{
  local _h ;
  _h = [ FDirName $(SUBDIR) $(>:BS=.cni.hpp) ] ;
  local _cpp ;
  _cpp = [ FDirName $(SUBDIR) $(>:BS=.cni.cxx) ] ;

  Depends $(_cpp) $(_h) : $(>) ;
  Includes $(_cpp) : $(_h) ;
  C++ $(<) : $(_cpp) ;

  RmTemps $(<) : $(_h) $(_cpp) ;
}
actions Cni
{
  "$(NICC_EXE)" "$(>)"
}

# /ObjectOptimFlags  sources : flags ;
#
# this rule is used to add flags to the optim compilation of
# specific sources files.
#
rule ObjectOptimFlags
{
  OPTIM on [ FGristFiles $(<:S=$(SUFOBJ)) ] ?= $(OPTIM) ;
  OPTIM on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;
}

# /ObjectCcFlags  sources : flags ;
#
# this rule is used to add compiler flags to the compilation of
# specific C sources files.
#
rule ObjectCcFlags
{
  CCFLAGS on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;
}

# /ObjectC99Flags  sources : flags ;
#
# this rule is used to add compiler flags to the compilation of
# specific C sources files.
#
rule ObjectC99Flags
{
  C99FLAGS on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;
}

# /ObjectC++Flags  sources : flags ;
#
# this rule is used to add compiler flags to the compilation of
# specific C++ source files
#
rule ObjectC++Flags
{
  C++FLAGS on [ FGristFiles $(<:S=$(SUFOBJ)) ] += $(>) ;
}

# /ObjectCC++Flags sources : flags ;
rule ObjectCC++Flags
{
  ObjectCcFlags $(<) : $(>) ;
  ObjectC++Flags $(<) : $(>) ;
}

# /ObjectCompiler objects : compiler ;
rule ObjectCompiler
{
  local s = [ FGristFiles $(<:S=$(SUFOBJ)) ] ;
  COMPILER on $(s) = $(>) ;
}

# /ObjectDefines  objects : macros ;
#
# this rule is used to add macro defines to the compilation of
# specific C and C++ source files
#
rule ObjectDefines
{
  # must reformat CCDEFS according to current defines

  local s = [ FGristFiles $(<:S=$(SUFOBJ)) ] ;

  DEFINES on $(s) ?= $(DEFINES) ;
  CCDEFS on $(s) ?= $(CCDEFS) ;
  DEFINES on $(s) += $(>) ;
  CCDEFS on $(s) += [ on $(s) FDefines $(DEFINES) ] ;
}

# /ObjectHdrs  sources : paths ;
#
# this rule is used to add include paths to the compilation of
# specific C and C++ source files
#
rule ObjectHdrs
{
  # Add to HDRS for HdrScan's benefit.
  # must reformat CCHDRS according to headers

  local s = [ FGristFiles $(<:S=$(SUFOBJ)) ] ;

  HDRS on $(s) += $(>) ;
  CCHDRS on $(s) = [ on $(s) FIncludes $(HDRS) ] ;
}

# Return the suffix of the specified source file
rule FTargetSuffix
{
  switch $(<:S) {
    case .java : return $(SUFJAVAC) ;
    case .scala : return $(SUFJAVAC) ;
    case .erl :	return $(SUFBEAM) ;
    case .asm : return $(SUFOBJ) ;
    case .masm : return $(SUFOBJ) ;
    case .c : return $(SUFOBJ) ;
    case .c99 : return $(SUFOBJ) ;
    case .m : return $(SUFOBJ) ;
    case .C : return $(SUFOBJ) ;
    case .cc : return $(SUFOBJ) ;
    case .cpp : return $(SUFOBJ) ;
    case .cxx : return $(SUFOBJ) ;
    case .c++ : return $(SUFOBJ) ;
    case .C++ : return $(SUFOBJ) ;
    case .mm  : return $(SUFOBJ) ;
    case .d : return $(SUFOBJ) ;
    case .f : return $(SUFOBJ) ;
    case .s : return $(SUFOBJ) ;
    case .rc : return $(SUFOBJ) ;
    case .cni : return $(SUFOBJ) ;
  }
  return $(<:S) ;
}

rule FTarget
{
  local s = [ FTargetSuffix $(<) ] ;
  return $(<:S=$(s)) ;
}

# ObjectSuf SOURCE
# call the Object rule with the appropriate suffix, returns the name
# of the target
rule ObjectSuf
{
  local suf = [ FTargetSuffix $(<) ] ;
  local d = $(<:S=$(suf)) ;
  switch $(suf) {
    case .class :
      Object $(d) : $(_i) ;
      Depends class : $(d) ;
    case .beam :
      Object $(d) : $(_i) ;
      Depends beam : $(d) ;
    case * :
      Object $(d) : $(_i) ;
      Depends obj : $(d) ;
  }
  return $(d) ;
}

# /Objects sources ;
#
# this rule is used to compile one or more sources into object files.
# do not call it directly, it is used by the Main and Library rules
# automatically
#
rule Objects
{
  local _i ;
  local r ;

  for _i in [ FGristFiles $(<) ]
  {
    r += [ ObjectSuf $(_i) ] ;
  }

  return $(r) ;
}

# /SharedObjects
#
# this rule is used to compile one or more sources into 'shared object
# files'. This means object files used to build either DLLs or Unix shared
# libraries.
#
# do not call this rule directly, it is called by SharedLibrary automatically
#
rule SharedObjects
{
  # temporarily override SUFOBJ with $(SUFDLLOBJ) to
  #
  local SUFOBJ = $(SUFDLLOBJ) ;

  # call the normal Objects rule
  #
  Objects $(<) ;
}

rule RmTemps
{
  Temporary $(>) ;
}

rule Setuid
{
  MODE on [ FAppendSuffix $(<) : $(SUFEXE) ] = 4711 ;
}

rule Shell
{
  Depends shell : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  MODE on $(<) = $(SHELLMODE) ;
  Clean clean : $(<) ;
  Chmod $(<) ;
}

rule SoftLink
{
  Depends files : $(<) ;
  Depends $(<) : $(>) ;
  SEARCH on $(>) = $(SEARCH_SOURCE) ;
  Clean clean : $(<) ;
}

rule SubDir
{
  #
  # SubDir TOP d1 d2 ... ;
  #
  # Support for a project tree spanning multiple directories.
  #
  # SubDir declares a Jamfile's location in a project tree, setting
  # Jambase variables (SEARCH_SOURCE, LOCATE_TARGET) so that source
  # files can be found.
  #
  # TOP is a user-select variable name for root of the tree, and
  # d1 d2 ...  are the directory elements that lead from the root
  # of the tree to the directory of the Jamfile.
  #
  # TOP can be set externally, but normally the first SubDir call
  # computes TOP as the path up from the current directory; the
  # path contains one ../ for each of d1 d2 ...
  #
  # SubDir reads once the project-specific rules file Jamrules
  # in the TOP directory, if present.  This can be overridden
  # with the variable TOPRULES.
  #
  # SubDir supports multiple, overlaid project trees:  SubDir
  # invocations with different TOPs can appear in the same Jamfile.
  # The location established by the first SubDir call is used set
  # the TOPs for the subsequent SubDir calls.
  #
  # SubDir's public variables:
  #
  #   $(TOP) = path from CWD to root.
  #   $(SUBDIR) = path from CWD to the directory SubDir names.
  #   $(SUBDIR_TOKENS) = path from $(TOP) to $(SUBDIR) as dir names
  #   $(SEARCH_SOURCE) = $(SUBDIR)
  #   $(LOCATE_SOURCE) = $(ALL_LOCATE_TARGET) $(SUBDIR)
  #   $(LOCATE_TARGET) = $(ALL_LOCATE_TARGET) $(SUBDIR)
  #   $(SOURCE_GRIST) = $(SUBDIR_TOKENS) with !'s
  #

  local _top = $(<[1]) ;
  local _tokens = $(<[2-]) ;

  #
  # First time through sets up relative root and includes Jamrules.
  #

  if ! $(_top)
  {
    Exit SubDir syntax error ;
  }

  if ! $($(_top)-SET)
  {
    $(_top)-SET = true ;

    # First time we've seen this TOP.
    # We'll initialize a number of internal variables:
    #
    #   $(TOP-UP) = directories from ROOT to a common point
    #   $(TOP-DOWN) = directories from common point to TOP
    #   $(TOP-ROOT) = root directory for UP/DOWN -- normally CWD
    #   $(SUBDIR_UP) = current value of $(TOP-UP)
    #   $(SUBDIR_DOWN) = current value of $(TOP-DOWN)
    #   $(SUBDIR_ROOT) = current value of $(TOP-ROOT)
    #

    if $($(_top))
    {
      # TOP externally set.
      # We'll ignore the relative (UP/DOWN) path that
      # got us here, and instead remember the hard ROOT.

      $(_top)-UP = ;
      $(_top)-DOWN = ;
      $(_top)-ROOT = $($(_top)) ;
    }
    else
    {
      # TOP not preset.

      # Establishing a new TOP.  In the simplest case,
      # (SUBDIR_UP/SUBDIR_DOWN/SUBDIR_ROOT unset), it's
      # merely a certain number of directories down from
      # the current directory, and FSubDirPath will set
      # TOP to a path consisting of ../ for each of the
      # elements of _tokens, because that represents how
      # far below TOP the current directory sits.
      #
      # In the more complicated case, the starting directory
      # isn't the directory of jam's invocation but an
      # location established by previous SubDir call.  The
      # starting directory is SUBDIR_UP directories up from
      # SUBDIR_ROOT, and then SUBDIR_DOWN directories down
      # from that.   If SUBDIR_ROOT is not set, that means
      # SUBDIR_DOWN and SUBDIR_UP represent the path from
      # the directory of jam's invocation.
      #
      # In the most complicated case, the _tokens also
      # represents directories down, because TOP is being
      # estalished in a directory other than TOP's root.
      # Hopefully, _tokens and SUBDIR_DOWN represent the
      # same final directory, relative to the new TOP and
      # the previous SubDIr's TOP.  To find the new TOP,
      # we have to chop off any common directories from
      # then ends of _tokens and SUBDIR_DOWN.  To do so,
      # we reverse each of them, call FStripCommon to
      # remove the initial common elements, and then
      # reverse them again.  After this process, if
      # both _tokens and SUBDIR_DOWN have elements, it
      # means the directory names estalished by the two
      # SubDir calls don't match, and a warning is issued.
      # All hell will likely break loose at this point,
      # since the whole SubDir scheme relies on the SubDir
      # calls accurately naming the current directory.

      # Strip common trailing elements of _tokens and SUBDIR_DOWN.

      _tokens = [ FReverse $(_tokens) ] ;
      SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;
      FStripCommon _tokens : SUBDIR_DOWN ;
      SUBDIR_DOWN = [ FReverse $(SUBDIR_DOWN) ] ;
      _tokens = [ FReverse $(_tokens) ] ;

      if $(SUBDIR_DOWN) && $(_tokens)
      {
        Echo Warning: SubDir $(<) misplaced! ;
      }

      # We'll remember the relative (UP/DOWN) path that
      # got us here, plus any hard ROOT starting point
      # for the UP/DOWN.  If TOP is never set externally,
      # ROOT will always be "" (directory of jam's invocation).

      $(_top)-UP = $(SUBDIR_UP) $(_tokens) ;
      $(_top)-DOWN = $(SUBDIR_DOWN) ;
      $(_top)-ROOT = $(SUBDIR_ROOT:E="") ;
      $(_top) = [ FSubDirPath $(_top) ] ;
    }

    # Set subdir vars for the inclusion of the Jamrules,
    # just in case they have SubDir rules of their own.
    # Note that SUBDIR_DOWN is empty: it's all the way
    # up where the Jamrules live.  These gets overrided
    # just after the inclusion.

    SUBDIR_UP = $($(_top)-UP) ;
    SUBDIR_DOWN = ;
    SUBDIR_ROOT = $($(_top)-ROOT) ;

    # Include $(TOPRULES) or $(TOP)/Jamrules.
    # Include $(TOPRULES) if set.
    # Otherwise include $(TOP)/Jamrules if present.

    if $($(_top)RULES) {
      include $($(_top)RULES) ;
    }
    else {
      NoCare $(JAMRULES:R=$($(_top)):G=$(_top)) ;
      include $(JAMRULES:R=$($(_top)):G=$(_top)) ;
    }
  }

  # Get path from $(TOP) to named directory.
  # Save dir tokens for other potential uses.

  SUBDIR_UP = $($(_top)-UP) ;
  SUBDIR_DOWN = $($(_top)-DOWN) $(_tokens) ;
  SUBDIR_ROOT = $($(_top)-ROOT) ;
  SUBDIR_TOKENS = $(SUBDIR_DOWN) ;

  SUBDIR = [ FSubDirPath $(<) ] ;

  # Now set up SEARCH_SOURCE, LOCATE_TARGET, SOURCE_GRIST
  # These can be reset if needed.  For example, if the source
  # directory should not hold object files, LOCATE_TARGET can
  # subsequently be redefined.

  SEARCH_SOURCE = $(SUBDIR) ;
  LOCATE_SOURCE = $(ALL_LOCATE_TARGET) $(SUBDIR) ;
  LOCATE_TARGET = $(ALL_LOCATE_TARGET) $(SUBDIR) ;
  SOURCE_GRIST = [ FGrist $(SUBDIR_TOKENS) ] ;

  # Reset per-directory ccflags, hdrs, etc,
  # listed in SUBDIRRESET.
  # Note use of variable expanded assignment var

  SUBDIR$(SUBDIRRESET) = ;

  # Invoke user-specific SubDir extensions,
  # rule names listed in SUBDIRRULES.
  # Note use of variable expanded rule invocation

  $(SUBDIRRULES) $(<) ;
}

rule FSubDirPath
{
  # FSubDirPath TOP d1 ... ;

  # Returns path to named directory.

  # If jam is invoked in a subdirectory of the TOP, then we
  # need to prepend a ../ for every level we must climb up
  # (TOP-UP), and then append the directory names we must
  # climb down (TOP-DOWN), plus the named directories d1 ...
  # If TOP was set externally, or computed from another TOP
  # that was, we'll have to reroot the whole thing at TOP-ROOT.

  local _r = [ FRelPath $($(<[1])-UP) : $($(<[1])-DOWN) $(<[2-]) ] ;

  return $(_r:R=$($(<[1])-ROOT)) ;
}

rule SubDirDcFlags
{
  SUBDIRDCFLAGS += $(<) ;
}

rule SubDirCcFlags
{
  SUBDIRCCFLAGS += $(<) ;
}

rule SubDirC++Flags
{
  SUBDIRC++FLAGS += $(<) ;
}

rule SubDirCC++Flags
{
  SubDirCcFlags $(<) ;
  SubDirC++Flags $(<) ;
}

rule SubDirHdrs
{
  SUBDIRHDRS += [ FDirName $(<) ] ;
}

rule SubInclude
{
  # SubInclude TOP d1 ... ;
  #
  # Include a subdirectory's Jamfile.

  # We use SubDir to get there, in case the included Jamfile
  # either doesn't have its own SubDir (naughty) or is a subtree
  # with its own TOP.

  if ! $($(<[1]))
  {
    Exit SubInclude '$(<[1])' without prior SubDir '$(<[1])' ;
  }

  SubDir $(<) ;

  include $(JAMFILE:D=$(SUBDIR)) ;
}

rule SubRules
{
  # SubRules TOP d1 ... : Other-TOP ;
  #
  # Read another tree's Jamrules, by giving it's path according
  # to this tree and it's own name.

  if ! $($(<[1]))
  {
    Exit SubRules $(<[1]) without prior SubDir $(<[1]) ;
  }

  SubDir $(<) ;
  SubDir $(>) ;
}

rule Undefines
{
  UNDEFS on [ FAppendSuffix $(<) : $(SUFEXE) ] += $(UNDEFFLAG)$(>) ;
}

rule UserObject
{
  Exit "Unknown suffix on" $(>) "- see UserObject rule in Jamfile(5)." ;
}

#
# Utility rules; no side effects on these
#

# /FGrist path to file ;
#
# Returns a single string that is used as grist
#
rule FGrist
{
  return $(<:J=!) ;

}

rule FGristFilesForDepends {
  return [ Subst [ FGristFiles $(<) ] : "%!" : "%/" ] ;
}

rule FGristFiles
{
  return $(<:G=$(SOURCE_GRIST:E)) ;
}


rule FGristSourceFiles
{
  # Produce source file name name with grist in it,
  # if SOURCE_GRIST is set.

  # Leave header files alone, because they have a global
  # visibility.

  if ! $(SOURCE_GRIST)
  {
    return $(<) ;
  }
  else
  {
    local _i _o ;

    for _i in $(<)
    {
      switch $(_i)
      {
        case *.h :  _o += $(_i) ;
        case * :    _o += $(_i:G=$(SOURCE_GRIST)) ;
      }
    }

    return $(_o) ;
  }
}

rule FReverse
{
  if $(1) { return [ FReverse $(1[2-]) ] $(1[1]) ; }
}


rule FSubDir
{
  # If $(>) is the path to the current directory, compute the
  # path (using ../../ etc) back to that root directory.
  # Sets result in $(<)

  if ! $(<[1])
  {
    return $(DOT) ;
  }
  else
  {
    local _i _d ;

    _d = $(DOTDOT) ;

    for _i in $(<[2-])
    {
      _d = $(_d:R=$(DOTDOT)) ;
    }

    return $(_d) ;
  }
}


rule FStripCommon
{
  # FStripCommon v1 : v2 ;

  # Strip common initial elements of variables v1 and v2.
  # Modifies the variable values themselves.

  if $($(<)[1]) && $($(<)[1]) = $($(>)[1])
  {
    $(<) = $($(<)[2-]) ;
    $(>) = $($(>)[2-]) ;
    FStripCommon $(<) : $(>) ;
  }
}


rule FRelPath
{
  local _l _r ;

  # first strip off common parts

  _l = $(<) ;
  _r = $(>) ;

  FStripCommon _l : _r ;

  # now make path to root and path down

  _l = [ FSubDir $(_l) ] ;
  _r = [ FDirName $(_r) ] ;

  # Concatenate and save

  # XXX This should be better

  if $(_r) = $(DOT) {
    return $(_l) ;
    } else {
      return $(_r:R=$(_l)) ;
    }
}


rule FAppendSuffix
{
  # E.g., "FAppendSuffix yacc lex foo.bat : $(SUFEXE) ;"
  # returns (yacc,lex,foo.bat) on Unix and
  # (yacc.exe,lex.exe,foo.bat) on NT.

  if $(>)
  {
    local _i _o ;

    for _i in $(<)
    {
      if $(_i:S)
      {
        _o += $(_i) ;
      }
      else
      {
        _o += $(_i:S=$(>)) ;
      }
    }
    return $(_o) ;
  }
  else
  {
    return $(<) ;
  }
}

#
# Operating system specific utility rules
# First, the (generic) UNIX versions
#

rule FDefinesDash { return -D$(<) ; }
rule FIncludesDash { return -I$(<) ; }
rule FDefinesSlash { return /D$(<) ; }
rule FIncludesSlash { return /I$(<) ; }

rule FDefines {
  return -D$(<) ;
}
rule FIncludes {
  local incdir = $(<) ;
  local absIncdir = [ FGetAbsolutePath $(<) ] ;
  return -I"\"$(absIncdir)\"" ;
}
rule FIncludesLint {
  local incdir = $(<) ;
  local absIncdir = [ FGetAbsolutePath $(<) ] ;
  return -i"\"$(absIncdir)\"" ;
}

# FOptionPath OPTION : PATH
rule FOptionPath {
  local r = ;
  for _d in $(>) {
    r += "$(<)""\"$(_d)\"" ;
  }
  return $(r) ;
}

# FOptionPathWithSpace OPTION : PATH
rule FOptionPathWithSpace {
  local r = ;
  for _d in $(>) {
    r += "$(<)" "\"$(_d)\"" ;
  }
  return $(r) ;
}

# Remove all .. and . from a list to create a "clean" list that can be used to build absolute path
rule FCleanDirs {
  local r = ;
  local prevprev = ;
  local prev = ;
  for _d in $(<) {
    if $(_d) = $(DOTDOT) {
      r = $(prev) ;
    }
    else if $(_d) = $(DOT) {
    }
    else {
      prev = $(r) ;
      r += $(_d) ;
    }
  }
  return $(r) ;
}

# Return an absolute directory path from a path which is relative to the SUBDIR
rule FSubDirAbsName {
  if ! $(TOP_DIR) {
    EXIT "The TOP_DIR environment variable must be set in your local _rules.ham." ;
  }

  local d = [ FCleanDirs $(SUBDIR_TOKENS) $(<) ] ;
  return [ FDirName $(TOP_DIR) $(d) ] ;
}

#
# Default actions
#
actions updated together piecemeal Archive
{
  "$(AR)" "$(<)" "$(>)"
}

actions As
{
  "$(AS)" $(ASFLAGS) $(ASHDRS) -o "$(<)" "$(>)"
}

actions Yasm
{
  "$(YASM)" $(YASMFLAGS) $(YASMHDRS) $(YASMDEFS) -o "$(<)" "$(>)"
}

actions Masm
{
   ml -nologo -Fo "$(<)" -c "$(>)"
}

actions Cc
{
  SRC_ABSPATH="`pwd`/$(>)"
  $(CC) -c -o "$(<)" $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) "${SRC_ABSPATH}"
}

actions C99
{
  SRC_ABSPATH="`pwd`/$(>)"
  $(CC) -c -o "$(<)" $(CCFLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) "${SRC_ABSPATH}"
}

actions C++
{
  SRC_ABSPATH="`pwd`/$(>)"
  $(C++) -c -o "$(<)" $(C++FLAGS) $(OPTIM) $(CCDEFS) $(CCHDRS) "${SRC_ABSPATH}"
}

rule LintC
{
  Depends $(<) : $(>) ;
  Depends lint : $(<) ;
  LINT_HDRS on $(<) = [ on $(<) FIncludesLint $(HDRS) ] ;
}
actions LintC
{
  $(LINT_C) $(LINT_HDRS) "$(>)" ; $(LINT_CANNOT_FAIL)
}

rule LintH
{
  Depends $(<) : $(>) ;
  Depends lint : $(<) ;
  LINT_HDRS on $(<) = [ on $(<) FIncludesLint $(HDRS) ] ;
}
actions LintH
{
  $(LINT_H) $(LINT_HDRS) "$(>)" ; $(LINT_CANNOT_FAIL)
}

actions Chgrp
{
  ham-exec-retry $(CHGRP) $(GROUP) "$(<)"
}

actions Chmod1
{
  ham-exec-retry $(CHMOD) $(MODE) "$(<)"
}

actions Chown
{
  ham-exec-retry $(CHOWN) $(OWNER) "$(<)"
}

actions piecemeal together existing Clean
{
  ham-exec-retry $(RM) "$(>)"
}

actions Cp
{
  ham-exec-retry $(CP) "$(>)" "$(<)"
}

rule Touch {
}
actions Touch {
  ham-exec-retry touch "$(<)"
}

actions File
{
  ham-exec-retry $(CP) "$(>)" "$(<)"
}

actions FilePreserve
{
  ham-exec-retry $(CP_PRESERVE) "$(>)" "$(<)"
}

if $(UNIX) {
  actions GenFile1 {
    PATH="$PATH:."
    $(>[1]) "$(<)" "$(>[2-])"
  }
}
else {
  actions GenFile1 {
    $(>[1]) "$(<)" "$(>[2-])"
  }
}

actions HardLink
{
  ham-exec-retry $(RM) "$(<)" && $(LN) "$(>)" "$(<)"
}

actions Link bind NEEDLIBS
{
  $(LINK) $(LINKFLAGS) -o "$(<)" $(UNDEFS) "$(>)" $(NEEDLIBS) $(LINKLIBS) $(SYSTEM_LINKLIBS)
}

actions MkDir1
{
  $(MKDIR) "$(<)"
}

actions together Ranlib
{
  $(RANLIB) "$(<)"
}

actions quietly updated piecemeal together RmTemps
{
  ham-exec-retry $(RM) "$(>)"
}

actions Shell
{
  $(AWK) '
  NR == 1 { print "$(SHELLHEADER)" }
  NR == 1 && /^[#:]/ { next }
  /^##/ { next }
  { print }
  ' < "$(>)" > "$(<)"
}

actions SoftLink
{
  ham-exec-retry $(RM) "$(<)" && $(LN) -s "$(>)" "$(<)"
}

#
# Backwards compatibility with jam 1, where rules were uppercased.
#

rule BULK { Bulk $(<) : $(>) ; }
rule FILE { File $(<) : $(>) ; }
rule HDRRULE { HdrRule $(<) : $(>) ; }
rule LIBRARY { Library $(<) : $(>) ; }
rule LIBS { LinkLibraries $(<) : $(>) ; }
rule LINK { Link $(<) : $(>) ; }
rule MAIN { Main $(<) : $(>) ; }
rule SETUID { Setuid $(<) ; }
rule SHELL { Shell $(<) : $(>) ; }
rule UNDEFINES { Undefines $(<) : $(>) ; }

# The the absolute path of the specified path, using / as file separator
rule FGetAbsolutePath {
  local D = [ GetAbsolutePath $(1) ] ;
  return $(D:/) ;
}

# FDirNameFiles DIR : FILES
rule FDirNameFiles {
  local t ;
  for _i in $(>) {
    t += [ FDirName $(<) $(_i) ] ;
  }
  return $(t) ;
}

# SrcSubDir PACKAGE : d1 .. dn : OBJDIR : SRC
rule SrcSubDir
{
  SubDirHdrs $(SUBDIR) $(>) ;
  MakeLocate ObjDir_$(<) : [ FDirName $(3) $(>) ] ;
  NotFile ObjDir_$(<) ;
  NoUpdate ObjDir_$(<) ;
  Depends $(<) : ObjDir_$(<) ;
  local s = [ FDirNameFiles $(>) : $(4) ] ;
  Depends [ FGristFiles $(s) ] : ObjDir_$(<) ;
  return $(s) ;
}

# SrcSubDirGlob PACKAGE : d1 .. dn : OBJDIR : SRC_PATTERN
rule SrcSubDirGlob
{
  local d = [ FDirName $(SUBDIR) $(>) ] ;
  local s = [ GlobSrc $(d) : $(4) ] ;
  return [ SrcSubDir $(<) : $(>) : $(3) : $(s) ] ;
}

# SrcSubDir PACKAGE : d1 .. dn : OBJDIR : SRC
rule SrcSubDirNoHdrs
{
  MakeLocate ObjDir_$(<) : [ FDirName $(3) $(>) ] ;
  NotFile ObjDir_$(<) ;
  NoUpdate ObjDir_$(<) ;
  Depends $(<) : ObjDir_$(<) ;
  local s = [ FDirNameFiles $(>) : $(4) ] ;
  Depends [ FGristFiles $(s) ] : ObjDir_$(<) ;
  return $(s) ;
}

# SrcSubDirGlob PACKAGE : d1 .. dn : OBJDIR : SRC_PATTERN
rule SrcSubDirGlobNoHdrs
{
  local d = [ FDirName $(SUBDIR) $(>) ] ;
  local s = [ GlobSrc $(d) : $(4) ] ;
  return [ SrcSubDirNoHdrs $(<) : $(>) : $(3) : $(s) ] ;
}

# Return source files with the given extension
# REM: Excludes files starting with an underscore or a dot,
#      they are considered hidden/auto-generated.
# EXAMPLE: GlobSrc DIR : cpp h asm : basepattern ;
rule GlobSrcWithDir
{
  return [ GLOB [ FDirName $(<) ] : "[^_.]*"$(>) ] ;
}
rule GlobSrc
{
  local r ;
  local t = [ GlobSrcWithDir $(<) : $(>) ] ;
  for _i in $(t) {
    r += $(_i:B)$(_i:S) ;
  }
  return $(r) ;
}

# DataGlob BASEDIR : SUBDIR : EXTENSIONS
rule DataGlob {
  return [ GlobSrcWithDir [ FDirName $(1) $(2) ] : $(3) ] ;
}

# DataList BASEDIR : SUBDIR : FILES
rule DataList {
  local r = ;
  for _s in $(3) {
    r += [ FDirName $(1) $(2) $(_s) ] ;
  }
  return $(r) ;
}

# CopyDataToDir BASEDIR : FILES : DESTDIR ;
rule CopyDataToDir {
  local destDir = $(3) ;
  MkDir $(destDir) ;

  local r = ;
  for _s in $(>) {
    local s = [ StrAfterI $(_s) : "$(<)/" ] ;
    # ECHO "--[$(<)/] $(_s) -> $(s)" ;
    local dest = [ FDirName $(destDir) $(s) ] ;
    DEPENDS $(dest) : $(destDir) ;
    # ECHO "$(_s) -> $(dest)" ;
    File $(dest) : $(_s) ;
    r += $(dest) ;
  }
  return $(r) ;
}

# TargetLinkFlags TARGET : FLAGS ;
rule TargetLinkFlags
{
  LINKFLAGS on $(<) ?= $(LINKFLAGS) ;
  LINKFLAGS on $(<) += $(>) ;
}

# TargetLinkLibs TARGET : LIBS ;
rule TargetLinkLibs
{
  LINKLIBS on $(<) ?= $(LINKLIBS) ;
  for _l in $(>) {
    LINKLIBS on $(<) += $(_l) ;
  }
}

# FileExists File
# REM: Tests only the filename not the directory path
rule FileExists
{
  local f = [ GLOB "." : $(<) ] ;
  if $(f) {  return 1 ; }
  return 0 ;
}

rule TestFileExists
{
  local d = [ FDirName $(2) ] ;
  for _i in $(3) {
    local t = $(_i:B)$(_i:S) ;
    local f = [ GLOB $(d) : $(t) ] ;
    f = $(f:B)$(f:S) ;
    if ! ( $(f) = $(t) ) {
      # 	  Echo "FF: [$(f)] = [$(t)]" ;
      Exit "Test Failed : $(1) : Can't find '$(3)' in '$(d)'." ;
    }
  }
}

# Return 1 if the element has already been include, else 0
rule IncludeOnce {
  if $(NO_ONCEGUARD) { return 0 ; }
  local dir = [ FDirName $(<) ] ;
  local inList = [ ListContains $(ONCE_LIST) : $(dir) ] ;
  # ECHO "IncludeOnce=" $(inList) "-" $(dir) "?" $(ONCE_LIST) ;
  if $(inList) = 1 { return 1 ; }
  return 0 ;
}

rule SubDirOnce {
  if [ IncludeOnce $(<) ] = 1 { return 1 ; }
  ONCE_LIST += [ FDirName $(<) ] ;
  SubDir $(<) ;
  return 0 ;
}

# SrcListDeps $(SRC) : $(DEPENDENCIES)
rule SrcListDeps {
  DEPENDS [ FGristFiles $(<) ] : $(>) ;
}

# ListDirs BASEDIR : PATTERN : EXCLUDE PATTERN
rule ListDirs {
  local p ;
  if $(>) {
    p = $(>) ;
  }
  else {
    p = "*" ;
  }
  local xp = "*.." "*." "*/.." "*/." ;
  if $(3) {
    xp += $(3) ;
  }

  local r = ;
  for _i in $(<) {
    local f = [ GLOB [ FDirName $(_i) ] : $(p) ] ;
    for _f in $(f) {
      if [ FISDIR $(_f) ] && ! [ GLOBSTRING $(_f) : $(xp) ] {
        r += $(_f) ;
      }
    }
  }
  return $(r) ;
}

# ListDirsR BASEDIR : PATTERN : EXCLUDE PATTERN
# Recursively list directories INSIDE BASEDIR, doesn't list BASEDIR.
rule ListDirsR {
  local r = [ ListDirs $(<) : $(>) : $(3) ] ;
  for _d in $(r) {
    r += [ ListDirsR $(_d) : $(>) : $(3) ] ;
  }
  return $(r) ;
}

# ListFiles DIRS : PATTERN : EXCLUDE PATTERN
# Example: [ ListFiles [ ListDirsR $(SUBDIR) ] : *.c ] ] ;
rule ListFiles {
  local r ;
  local p ;
  if $(>) {
    p = $(>) ;
  }
  else {
    p = "*" ;
  }
  local xp = "*.." "*." "*/.." "*/." ;
  if $(3) {
    xp += $(3) ;
  }

  for _d in $(<) {
    local f = [ GLOB [ FDirName $(_d) ] : $(p) ] ;
    for _f in $(f) {
      local fn = $(_f:B)$(_f:S) ;
      if ! [ FISDIR $(_f) ] && ! [ GLOBSTRING $(fn) : $(xp) ] {
        r += $(_f) ;
      }
    }
  }
  return $(r) ;
}

# ListContains LIST : token
# Check whether the list contains the specified token
rule ListContains {
  for _d in $(<) {
    if $(_d) = $(>) {
      return 1 ;
    }
  }
  return ;
}

# ListAddFront LIST : token
rule ListAddFront {
  return $(>) $(<) ;
}

rule ListAddFrontOnce {
  if [ ListContains $(<) : $(>) ] {
    return $(<) ;
  }
  return [ ListAddFront $(<) : $(>) ] ;
}

# ListAddBack LIST : token
rule ListAddBack {
  return $(<) $(>) ;
}

rule ListAddBackOnce {
  if [ ListContains $(<) : $(>) ] {
    return $(<) ;
  }
  return [ ListAddBack $(<) : $(>) ] ;
}

rule ListFilter LIST : INCLUDE : EXCLUDE {
  local t = [ Match "("$(2)")" : $(1) ] ;
  if $(3) {
    local r = ;
    for i in $(t) {
      # ECHO "I:" $(3) ":" $(i) ":" [ Match "("$(3)")" : $(i) ] ;
      if [ Match "("$(3)")" : $(i) ] = "" {
        r += $(i) ;
      }
    }
    return $(r) ;
  }
  else {
    return $(t) ;
  }
}

# ListStrAfterI LIST : AFTERTOKEN
rule ListStrAfterI {
  local r = ;
  for _s in $(<) {
    local s = [ StrAfterI $(_s) : "$(>)/" ] ;
    r += $(s) ;
  }
  return $(r) ;
}

# Gather files in a folder recursivly
# ListFiles DIR : PATTERN : EXCLUDE PATTERN
rule ListFilesR {
  local BD = [ FDirName $(1) ] ;
  local FD = [ ListDirsR $(BD) ] ;
  local F2 = [ ListFiles $(BD) $(FD) : $(2) : $(3) ] ;
  return $(F2) ;
}

# Returns the first element in the list
rule ListGetFirst {
  for _s in $(<) {
    return $(_s) ;
  }
}

#----------------------------------------------------------------------
#     File generation rules
#----------------------------------------------------------------------
actions EmptyFile {
  echo "" > "$(<)"
}

rule FileCat {
  #   ECHO "CAT: " $(>) " to " $(<) ;
  DEPENDS $(<) : $(>) ;
}
actions FileCat {
  cat "$(>)" >> "$(<)"
}
rule FileCatList {
  EmptyFile $(<) ;
  for _i in $(>) {
    FileCat $(<) : $(_i) ;
  }
}

rule FileEcho {
  NOTFILE $(>) ;
}
actions FileEcho {
  echo "$(>)" >> "$(<)"
}
rule FileEchoList {
  EmptyFile $(<) ;
  for _i in $(>) {
    FileEcho $(<) : $(_i) ;
  }
}

#----------------------------------------------------------------------
#     Bin2H rules
#----------------------------------------------------------------------

# Bin2H DEST : SRC ;
rule Bin2H {
  # ECHO "DEST:" $(<) ;
  # ECHO "SRC:" $(>) ;
  local var = [ Subst $(<:B) : %. : _ ] ;
  # ECHO "VARNAME:" $(var) ;
  VARNAME on $(<) = $(var) ;
  DEPENDS $(<) : $(>) ;
  DEPENDS bin2h : $(<) ;
  return $(<) ;
}
actions Bin2H {
  bin2h $(>) $(<) $(VARNAME)
}

# DataSubDirBin2H TARGET : DIR : OBJDIR : EXTS
rule DataSubDirBin2H {
  local DATA = ;
  local EXTS = $(4) ;
  if ! $(EXTS) {
    EXTS = abm bmp dds jpg jpeg png tga xml wav flac ogg opus mp3 hdr psd avi ogv ogw mp4 ipcam webcam metal cgc cgo xib nib ttf txt ;
  }
  local DATA_SRC = [ SrcSubDirGlobNoHdrs $(1) : $(2) : $(3) : $(EXTS) ] ;
  # ECHO "DATA_SRC:" $(DATA_SRC) ;
  for _s in $(DATA_SRC) {
    local d = [ FGristFiles [ FDirName $(SUBDIR) $(_s).hxx ] ] ;
    local dep = [ FGristFilesForDepends [ FDirName $(_s).hxx ] ] ;
    local s = [ FDirName $(SUBDIR) $(_s) ] ;
    # ECHO "s:" $(s) "->" $(d) "--->" $(dep) ;
    local r = [ Bin2H $(d) : $(s) ] ;
    # ECHO "r:" $(r) ;
    DEPENDS $(d) : $(s) ;
    DEPENDS $(dep) : $(d) ;
    DATA += $(d) ;
  }
  # ECHO "DATA:" $(DATA) ;
  DEPENDS $(<) : $(DATA) ;
  return $(DATA) ;
}

#----------------------------------------------------------------------
#     VarOn
#----------------------------------------------------------------------
# VarOnGet VARNAME ONWHAT
rule VarOnGet_ {
  return $($(<)) ;
}
rule VarOnGet {
  return [ on $(2) VarOnGet_ $(1) ] ;
}

# VarOnAddToFront VARNAME ONWHAT TOADD
rule VarOnAddToFront {
  # ECHO "# VAR: " $(1) ;
  # ECHO "# ON: " $(2) ;
  # ECHO "# TOADD: " $(3) ;
  $(1) on $(2) = $(3) [ VarOnGet $(1) : $(2) ] ;
}

#----------------------------------------------------------------------
#     Run
#----------------------------------------------------------------------
rule RunExe {
  DEPENDS $(<) : $(>) ;
  if ! $(3) {
    if $(SUBDIR) {
      WORKDIR on $(<) = $(SUBDIR) ;
    }
    else {
      WORKDIR on $(<) = . ;
    }
  }
  else {
    WORKDIR on $(<) = $(3) ;
  }
}
actions RunExe {
  cd $(WORKDIR)
  "./$(>)$(SUFEXE)" $(A0) $(A1) $(A2) $(A3) $(A4) $(A5) $(A6) $(A7) $(A8) $(A9)
}

#----------------------------------------------------------------------
#     Flymake
#----------------------------------------------------------------------
# FlyMakeSetup TARGET : CHK_SOURCES : (noremovetemp) ;
rule FlyMakeSetup
{
  if $(FLYMAKE_DONE) { return ; }

  if $(>) {
    NOTFILE $(<) ;
    local s = [ FGristFiles [ FTarget $(>) ] ] ;
    Objects $(>) ;
    DEPENDS $(<) : $(s) ;
    if $(3) = noremovetemp {
      RmTemps $(<) : $(s) ;
    }
  }

  FLYMAKE_DONE = 1 ;
}

#----------------------------------------------------------------------
#     Standard directories and the cache file
#----------------------------------------------------------------------
TEMPDIR ?= [ FDirName $(HOME) _ham ] ;
BASEOBJDIR ?= [ FDirName $(TEMPDIR) obj ] ;
HCACHEFILE ?= [ FDirName $(TEMPDIR) _cache.ham ] ;

#----------------------------------------------------------------------
#     Include the toolset's base rules
#----------------------------------------------------------------------
Import base-$(HAM_TOOLSET)-rules.ham ;

#----------------------------------------------------------------------
#     Include the user's Hamfile
#----------------------------------------------------------------------
include $(JAMFILE) ;
